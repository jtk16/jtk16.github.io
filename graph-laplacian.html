<!-- graph-laplacian.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Interactive visualization of graph Laplacian eigenvalues and their effect on graph structure">
  <title>Graph Laplacian Eigenvalue Visualizer â€” Jack Kinney</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <style>
    /* CSS Variables matching your existing theme */
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --primary-light: #a5b4fc;
      --secondary: #ec4899;
      --accent: #f59e0b;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;

      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-tertiary: #e2e8f0;
      --bg-card: #ffffff;
      --bg-card-hover: #f1f5f9;

      --text-primary: #0f172a;
      --text-secondary: #475569;
      --text-muted: #64748b;

      --border: #e2e8f0;
      --border-light: #cbd5e1;

      --space-1: 0.25rem;
      --space-2: 0.5rem;
      --space-3: 0.75rem;
      --space-4: 1rem;
      --space-6: 1.5rem;
      --space-8: 2rem;
      --space-12: 3rem;
      --space-16: 4rem;

      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --font-mono: 'JetBrains Mono', 'SF Mono', 'Monaco', 'Consolas', monospace;

      --radius: 0.5rem;
      --radius-lg: 1rem;
      --radius-xl: 1.5rem;

      --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
      --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1);

      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-sans);
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      min-height: 100vh;
    }

    .container {
      width: 100%;
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 var(--space-6);
    }

    /* Header */
    .header {
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border);
      padding: var(--space-4) 0;
      position: sticky;
      top: 0;
      z-index: 100;
      backdrop-filter: blur(20px);
    }

    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--text-primary);
      font-family: var(--font-mono);
      text-decoration: none;
    }

    .back-link {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      color: var(--primary);
      text-decoration: none;
      font-weight: 500;
      transition: var(--transition);
    }

    .back-link:hover {
      color: var(--primary-dark);
    }

    /* Main Layout */
    .main-content {
      padding: var(--space-8) 0;
    }

    .app-header {
      text-align: center;
      margin-bottom: var(--space-12);
    }

    .app-title {
      font-size: 2.5rem;
      font-weight: 800;
      margin-bottom: var(--space-4);
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .app-description {
      font-size: 1.125rem;
      color: var(--text-secondary);
      max-width: 800px;
      margin: 0 auto;
    }

    /* App Layout */
    .app-container {
      display: grid;
      grid-template-columns: 350px 1fr;
      gap: var(--space-8);
      min-height: 600px;
    }

    .controls-panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      padding: var(--space-6);
      height: fit-content;
      position: sticky;
      top: 120px;
      box-shadow: var(--shadow-lg);
    }

    .visualization-panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      padding: var(--space-6);
      box-shadow: var(--shadow-lg);
    }

    /* Controls */
    .control-section {
      margin-bottom: var(--space-6);
    }

    .control-section:last-child {
      margin-bottom: 0;
    }

    .section-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: var(--space-4);
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .eigenvalue-control.snapped {
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid var(--success);
      border-radius: var(--radius);
      transform: scale(1.02);
      transition: all 0.3s ease;
    }

    .snap-tooltip {
      position: absolute;
      top: -35px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--success);
      color: white;
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius);
      font-size: 0.75rem;
      white-space: nowrap;
      z-index: 1000;
      animation: fadeInOut 1s ease;
    }

    .snap-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 4px solid transparent;
      border-top-color: var(--success);
    }

    @keyframes fadeInOut {
      0%, 100% { opacity: 0; transform: translateX(-50%) translateY(-5px); }
      20%, 80% { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Property Controls */
    .property-control {
      margin-bottom: var(--space-6);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-4);
      transition: var(--transition);
    }

    .property-control:hover {
      border-color: var(--primary);
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.1);
    }

    .property-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--space-3);
      font-weight: 600;
      color: var(--text-primary);
    }

    .property-label i {
      color: var(--text-muted);
      cursor: help;
    }

    .property-slider-container {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      margin-bottom: var(--space-2);
    }

    .property-slider {
      flex: 1;
      height: 8px;
      border-radius: 4px;
      background: var(--bg-tertiary);
      outline: none;
      transition: var(--transition);
      -webkit-appearance: none;
    }

    .property-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      transition: var(--transition);
    }

    .property-slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
    }

    .property-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    .slider-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      white-space: nowrap;
      font-weight: 500;
    }

    .property-value {
      text-align: center;
      font-size: 0.875rem;
      color: var(--primary);
      font-weight: 500;
      background: rgba(99, 102, 241, 0.1);
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius);
    }

    .help-text {
      font-size: 0.875rem;
      color: var(--text-muted);
      margin-bottom: var(--space-4);
      line-height: 1.5;
      font-style: italic;
    }

    .setting-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-3);
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .setting-label select {
      padding: var(--space-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: inherit;
    }

    .advanced-toggle {
      margin-top: var(--space-4);
    }

    .advanced-toggle label {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      font-size: 0.875rem;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .advanced-toggle input[type="checkbox"] {
      transform: scale(1.2);
      accent-color: var(--primary);
    }

    .advanced-section {
      border-top: 1px solid var(--border);
      padding-top: var(--space-6);
      margin-top: var(--space-6);
    }

    .explanation {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(236, 72, 153, 0.1));
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: var(--radius);
      padding: var(--space-4);
      font-size: 0.875rem;
      line-height: 1.6;
      color: var(--text-secondary);
      position: relative;
      overflow: hidden;
    }

    .explanation::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: linear-gradient(180deg, var(--primary), var(--secondary));
    }

    #eigenvalue-display {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
      font-family: var(--font-mono);
      font-size: 0.8rem;
      max-height: 150px;
      overflow-y: auto;
    }

    .eigenvalue-item {
      display: flex;
      justify-content: space-between;
      padding: var(--space-1) 0;
      border-bottom: 1px solid var(--border);
    }

    .eigenvalue-item:last-child {
      border-bottom: none;
    }

    .eigenvalue-item .label {
      color: var(--text-muted);
    }

    .eigenvalue-item .value {
      color: var(--primary);
      font-weight: 500;
    }

    .eigenvalue-label {
      display: flex;
      justify-content: between;
      align-items: center;
      margin-bottom: var(--space-2);
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .eigenvalue-slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--bg-tertiary);
      outline: none;
      transition: var(--transition);
      -webkit-appearance: none;
    }

    .eigenvalue-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: var(--shadow);
    }

    .eigenvalue-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: var(--shadow);
    }

    .preset-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-3);
    }

    .preset-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    .preset-btn {
      padding: var(--space-2) var(--space-3);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      color: var(--text-primary);
      font-size: 0.875rem;
      cursor: pointer;
      transition: var(--transition);
      font-family: inherit;
      position: relative;
      overflow: hidden;
    }

    .preset-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }

    .preset-btn:hover::before {
      left: 100%;
    }

    /* Remove old status display styles - replaced with integrated explanations */

    /* Canvas */
    .canvas-container {
      position: relative;
      width: 100%;
      height: 600px;
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      overflow: hidden;
      background: linear-gradient(45deg, #f8fafc 25%, transparent 25%), 
                  linear-gradient(-45deg, #f8fafc 25%, transparent 25%), 
                  linear-gradient(45deg, transparent 75%, #f8fafc 75%), 
                  linear-gradient(-45deg, transparent 75%, #f8fafc 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }

    #graph-canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #graph-canvas:active {
      cursor: grabbing;
    }

    .canvas-overlay {
      position: absolute;
      top: var(--space-4);
      right: var(--space-4);
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
      font-size: 0.875rem;
      backdrop-filter: blur(10px);
    }

    /* Info Panel */
    .info-panel {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--space-4);
      margin-top: var(--space-6);
    }

    .info-title {
      font-weight: 600;
      margin-bottom: var(--space-2);
      color: var(--text-primary);
    }

    .info-text {
      font-size: 0.875rem;
      color: var(--text-secondary);
      line-height: 1.6;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .app-container {
        grid-template-columns: 1fr;
        gap: var(--space-6);
      }

      .controls-panel {
        position: static;
        order: 2;
      }

      .preset-buttons {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 0 var(--space-4);
      }

      .app-title {
        font-size: 2rem;
      }

      .canvas-container {
        height: 400px;
      }

      .preset-buttons {
        grid-template-columns: 1fr 1fr;
      }
    }

    /* Loading Animation */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 200px;
      color: var(--text-muted);
      font-size: 0.875rem;
    }

    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-top: 2px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: var(--space-2);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="container">
      <div class="header-content">
        <a href="./index.html" class="logo">&lt;JTK/&gt;</a>
        <a href="./projects.html" class="back-link">
          <i class="fas fa-arrow-left"></i>
          Back to Projects
        </a>
      </div>
    </div>
  </header>

  <main class="main-content">
    <div class="container">
      <div class="app-header">
        <h1 class="app-title">Graph Laplacian Eigenvalue Visualizer</h1>
        <p class="app-description">
          Discover how graph connectivity, clustering, and spread affect network structure! 
          Adjust intuitive properties and watch as the mathematical eigenvalues automatically 
          update to create valid graph configurations. No spectral graph theory knowledge required.
        </p>
      </div>

      <div class="app-container">
        <div class="controls-panel">
          <div class="control-section">
            <h3 class="section-title">
              <i class="fas fa-network-wired"></i>
              Graph Properties
            </h3>
            <div class="help-text">
              Adjust how connected and clustered your graph is. The math happens automatically!
            </div>
            
            <div class="property-control">
              <div class="property-label">
                <span>How Connected?</span>
                <i class="fas fa-question-circle" title="Higher values create more tightly connected graphs"></i>
              </div>
              <div class="property-slider-container">
                <span class="slider-label">Sparse</span>
                <input type="range" class="property-slider" id="connectivity-slider" 
                       min="0" max="100" value="30" data-property="connectivity">
                <span class="slider-label">Dense</span>
              </div>
              <div class="property-value">Moderate connectivity</div>
            </div>

            <div class="property-control">
              <div class="property-label">
                <span>How Spread Out?</span>
                <i class="fas fa-question-circle" title="Controls how far apart different parts of the graph are"></i>
              </div>
              <div class="property-slider-container">
                <span class="slider-label">Tight</span>
                <input type="range" class="property-slider" id="expansion-slider" 
                       min="0" max="100" value="50" data-property="expansion">
                <span class="slider-label">Spread</span>
              </div>
              <div class="property-value">Balanced spread</div>
            </div>

            <div class="property-control">
              <div class="property-label">
                <span>How Clustered?</span>
                <i class="fas fa-question-circle" title="Higher values create more distinct groups or clusters"></i>
              </div>
              <div class="property-slider-container">
                <span class="slider-label">Uniform</span>
                <input type="range" class="property-slider" id="clustering-slider" 
                       min="0" max="100" value="25" data-property="clustering">
                <span class="slider-label">Clustered</span>
              </div>
              <div class="property-value">Low clustering</div>
            </div>
          </div>

          <div class="control-section">
            <h3 class="section-title">
              <i class="fas fa-shapes"></i>
              Common Examples
            </h3>
            <div class="help-text">
              Try these classic graph types to see how properties change
            </div>
            <div class="preset-buttons">
              <button class="preset-btn" data-preset="path" title="Nodes in a line">
                <i class="fas fa-minus"></i> Chain
              </button>
              <button class="preset-btn" data-preset="cycle" title="Nodes in a circle">
                <i class="fas fa-circle-notch"></i> Ring
              </button>
              <button class="preset-btn" data-preset="star" title="One center, many spokes">
                <i class="fas fa-star"></i> Star
              </button>
              <button class="preset-btn" data-preset="complete" title="Everyone connected to everyone">
                <i class="fas fa-project-diagram"></i> Complete
              </button>
            </div>
          </div>

          <div class="control-section">
            <h3 class="section-title">
              <i class="fas fa-cog"></i>
              Settings
            </h3>
            <label class="setting-label">
              <span>Number of nodes:</span>
              <select id="node-count">
                <option value="4">4 nodes</option>
                <option value="5" selected>5 nodes</option>
                <option value="6">6 nodes</option>
                <option value="7">7 nodes</option>
                <option value="8">8 nodes</option>
              </select>
            </label>
            
            <div class="advanced-toggle">
              <label>
                <input type="checkbox" id="show-advanced"> 
                Show eigenvalue details
              </label>
            </div>
          </div>

          <div class="control-section advanced-section" style="display: none;">
            <h3 class="section-title">
              <i class="fas fa-calculator"></i>
              Mathematical Details
            </h3>
            <div class="help-text">
              The eigenvalues that make your graph possible (auto-calculated)
            </div>
            <div id="eigenvalue-display">
              <!-- Eigenvalues shown as read-only information -->
            </div>
          </div>

          <div class="control-section">
            <h3 class="section-title">
              <i class="fas fa-lightbulb"></i>
              What You're Seeing
            </h3>
            <div id="explanation-text" class="explanation">
              Drag the sliders above to see how different properties affect your graph's structure!
            </div>
          </div>
        </div>

        <div class="visualization-panel">
          <div class="canvas-container">
            <canvas id="graph-canvas"></canvas>
            <div class="canvas-overlay">
              <div><strong>Network Health:</strong> <span id="spectral-gap">0.00</span></div>
              <div><strong>Connection Strength:</strong> <span id="algebraic-connectivity">0.00</span></div>
              <div style="font-size: 0.75rem; margin-top: 0.5rem; opacity: 0.8;">
                Higher values = better connectivity
              </div>
            </div>
          </div>

          <div class="info-panel">
            <div class="info-title">How This Works</div>
            <div class="info-text">
              Behind the scenes, this tool uses <strong>spectral graph theory</strong> - a branch of mathematics 
              that connects graph structure to eigenvalues. When you adjust properties like connectivity, 
              the tool automatically finds valid eigenvalue sets that create those graph characteristics. 
              You can explore advanced details using the checkbox above, but it's designed to be intuitive 
              without needing mathematical background.
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    // graph-laplacian-engine.js - Core mathematical operations
    class GraphLaplacianEngine {
      constructor() {
        this.tolerance = 1e-10;
        this.maxIterations = 1000;
      }

      // Generate eigenvalues for common graph types
      getPresetEigenvalues(type, n) {
        switch(type) {
          case 'path':
            return this.pathGraphEigenvalues(n);
          case 'cycle':
            return this.cycleGraphEigenvalues(n);
          case 'complete':
            return this.completeGraphEigenvalues(n);
          case 'star':
            return this.starGraphEigenvalues(n);
          case 'wheel':
            return this.wheelGraphEigenvalues(n);
          case 'random':
            return this.randomValidEigenvalues(n);
          default:
            return new Array(n).fill(0).map((_, i) => i);
        }
      }

      pathGraphEigenvalues(n) {
        const eigenvals = [0]; // First eigenvalue is always 0
        for (let k = 1; k < n; k++) {
          eigenvals.push(2 - 2 * Math.cos((k * Math.PI) / (n + 1)));
        }
        return eigenvals.sort((a, b) => a - b);
      }

      cycleGraphEigenvalues(n) {
        const eigenvals = [];
        for (let k = 0; k < n; k++) {
          eigenvals.push(2 - 2 * Math.cos((2 * Math.PI * k) / n));
        }
        return eigenvals.sort((a, b) => a - b);
      }

      completeGraphEigenvalues(n) {
        const eigenvals = [0];
        for (let i = 1; i < n; i++) {
          eigenvals.push(n);
        }
        return eigenvals;
      }

      starGraphEigenvalues(n) {
        const eigenvals = [0, 1];
        for (let i = 2; i < n; i++) {
          eigenvals.push(1);
        }
        eigenvals[n - 1] = n;
        return eigenvals.sort((a, b) => a - b);
      }

      wheelGraphEigenvalues(n) {
        // Wheel graph: cycle + center node
        const cycleEigenvals = this.cycleGraphEigenvalues(n - 1);
        return [0, ...cycleEigenvals.slice(1).map(x => x + 1), n];
      }

      randomValidEigenvalues(n) {
        // Generate random but valid eigenvalue set
        const eigenvals = [0]; // Always start with 0
        for (let i = 1; i < n; i++) {
          eigenvals.push(Math.random() * 4 + 0.1);
        }
        return eigenvals.sort((a, b) => a - b);
      }

      // Check if eigenvalues are valid for a graph
      validateEigenvalues(eigenvals) {
        const n = eigenvals.length;
        
        // Basic checks
        if (Math.abs(eigenvals[0]) > this.tolerance) {
          return { valid: false, reason: "First eigenvalue must be 0 (connected components)" };
        }

        for (let i = 0; i < n - 1; i++) {
          if (eigenvals[i] > eigenvals[i + 1] + this.tolerance) {
            return { valid: false, reason: "Eigenvalues must be in non-decreasing order" };
          }
        }

        // Check for disconnected graph (multiple zero eigenvalues)
        let zeroCount = 0;
        for (let i = 0; i < n; i++) {
          if (Math.abs(eigenvals[i]) < this.tolerance) zeroCount++;
        }
        
        if (zeroCount > 1) {
          return { valid: false, reason: `Graph has ${zeroCount} connected components` };
        }

        // Check algebraic connectivity
        if (eigenvals[1] < this.tolerance && n > 1) {
          return { valid: false, reason: "Graph is disconnected (algebraic connectivity = 0)" };
        }

        // Advanced checks: interlacing properties and realizability
        const confidence = this.computeConfidence(eigenvals);
        const realizability = this.checkRealizability(eigenvals);
        
        if (realizability.realizable) {
          return { valid: true, confidence, graphType: realizability.graphType };
        } else {
          return { 
            valid: false, 
            reason: realizability.reason,
            confidence: confidence * 0.5 // Partially valid but not realizable
          };
        }
      }

      checkRealizability(eigenvals) {
        const n = eigenvals.length;
        
        // Check against known graph families
        const tolerance = 0.05;
        
        // Path graph check
        const pathEigenvals = this.pathGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, pathEigenvals, tolerance)) {
          return { realizable: true, graphType: 'path' };
        }
        
        // Cycle graph check
        const cycleEigenvals = this.cycleGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, cycleEigenvals, tolerance)) {
          return { realizable: true, graphType: 'cycle' };
        }
        
        // Complete graph check
        const completeEigenvals = this.completeGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, completeEigenvals, tolerance)) {
          return { realizable: true, graphType: 'complete' };
        }
        
        // Star graph check
        const starEigenvals = this.starGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, starEigenvals, tolerance)) {
          return { realizable: true, graphType: 'star' };
        }
        
        // General realizability heuristics
        const maxPossibleEigenvalue = 2 * n; // Upper bound for regular graphs
        if (eigenvals[n - 1] > maxPossibleEigenvalue) {
          return { 
            realizable: false, 
            reason: `Max eigenvalue ${eigenvals[n - 1].toFixed(2)} exceeds theoretical bound ${maxPossibleEigenvalue}` 
          };
        }
        
        // Check eigenvalue gaps (very large gaps are suspicious)
        for (let i = 1; i < n - 1; i++) {
          const gap = eigenvals[i + 1] - eigenvals[i];
          if (gap > n) {
            return { 
              realizable: false, 
              reason: `Unusually large eigenvalue gap (${gap.toFixed(2)}) between Î»${i+1} and Î»${i+2}` 
            };
          }
        }
        
        return { realizable: true, graphType: 'general' };
      }

      eigenvaluesMatch(eigenvals1, eigenvals2, tolerance) {
        if (eigenvals1.length !== eigenvals2.length) return false;
        
        for (let i = 0; i < eigenvals1.length; i++) {
          if (Math.abs(eigenvals1[i] - eigenvals2[i]) > tolerance) return false;
        }
        return true;
      }

      computeConfidence(eigenvals) {
        // Heuristic to determine how "graph-like" the eigenvalues are
        const n = eigenvals.length;
        let score = 1.0;

        // Penalize very large gaps
        for (let i = 1; i < n - 1; i++) {
          const gap = eigenvals[i + 1] - eigenvals[i];
          if (gap > 3) score *= 0.8;
        }

        // Penalize very large eigenvalues
        const maxEigenval = eigenvals[n - 1];
        if (maxEigenval > 2 * n) score *= 0.7;

        return Math.max(0.1, Math.min(1.0, score));
      }

      // Project invalid eigenvalues to nearest valid set
      projectToValidEigenvalues(eigenvals) {
        const projected = [...eigenvals].sort((a, b) => a - b);
        projected[0] = 0; // Ensure first eigenvalue is 0
        
        // Ensure non-negativity
        for (let i = 0; i < projected.length; i++) {
          projected[i] = Math.max(0, projected[i]);
        }

        // Ensure algebraic connectivity > 0 (except for disconnected graphs)
        if (projected.length > 1 && projected[1] < 0.01) {
          projected[1] = 0.1;
        }

        return projected;
      }

      // Generate approximate graph from eigenvalues
      generateGraphFromEigenvalues(eigenvals) {
        const n = eigenvals.length;
        const positions = this.generateSpectralPositions(eigenvals);
        const adjacency = this.constructAdjacencyMatrix(eigenvals, positions);
        
        return {
          positions,
          adjacency,
          eigenvalues: eigenvals,
          properties: this.computeGraphProperties(eigenvals)
        };
      }

      generateSpectralPositions(eigenvals) {
        const n = eigenvals.length;
        const positions = [];
        
        // Use first few eigenvalues to determine 2D embedding
        for (let i = 0; i < n; i++) {
          const angle = (2 * Math.PI * i) / n;
          const radius = 150 + 50 * Math.sin(eigenvals[Math.min(i, eigenvals.length - 1)]);
          
          positions.push({
            x: 300 + radius * Math.cos(angle),
            y: 300 + radius * Math.sin(angle)
          });
        }
        
        return positions;
      }

      constructAdjacencyMatrix(eigenvals, positions) {
        const n = eigenvals.length;
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        
        // Determine graph type based on eigenvalue pattern
        const graphType = this.detectGraphType(eigenvals);
        
        switch(graphType) {
          case 'path':
            return this.createPathAdjacency(n);
          case 'cycle':
            return this.createCycleAdjacency(n);
          case 'complete':
            return this.createCompleteAdjacency(n);
          case 'star':
            return this.createStarAdjacency(n);
          default:
            return this.createHeuristicAdjacency(eigenvals, positions);
        }
      }

      detectGraphType(eigenvals) {
        const n = eigenvals.length;
        const tolerance = 0.1;
        
        // Check for path graph pattern
        const pathEigenvals = this.pathGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, pathEigenvals, tolerance)) return 'path';
        
        // Check for cycle graph pattern  
        const cycleEigenvals = this.cycleGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, cycleEigenvals, tolerance)) return 'cycle';
        
        // Check for complete graph pattern
        const completeEigenvals = this.completeGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, completeEigenvals, tolerance)) return 'complete';
        
        // Check for star graph pattern
        const starEigenvals = this.starGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, starEigenvals, tolerance)) return 'star';
        
        return 'unknown';
      }

      eigenvaluesMatch(eigenvals1, eigenvals2, tolerance) {
        if (eigenvals1.length !== eigenvals2.length) return false;
        
        for (let i = 0; i < eigenvals1.length; i++) {
          if (Math.abs(eigenvals1[i] - eigenvals2[i]) > tolerance) return false;
        }
        return true;
      }

      createPathAdjacency(n) {
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        for (let i = 0; i < n - 1; i++) {
          adjacency[i][i + 1] = adjacency[i + 1][i] = 1;
        }
        return adjacency;
      }

      createCycleAdjacency(n) {
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        for (let i = 0; i < n - 1; i++) {
          adjacency[i][i + 1] = adjacency[i + 1][i] = 1;
        }
        adjacency[0][n - 1] = adjacency[n - 1][0] = 1;
        return adjacency;
      }

      createCompleteAdjacency(n) {
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            adjacency[i][j] = adjacency[j][i] = 1;
          }
        }
        return adjacency;
      }

      createStarAdjacency(n) {
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        // Connect all nodes to node 0 (center)
        for (let i = 1; i < n; i++) {
          adjacency[0][i] = adjacency[i][0] = 1;
        }
        return adjacency;
      }

      createHeuristicAdjacency(eigenvals, positions) {
        const n = eigenvals.length;
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            const spectralDistance = this.computeSpectralDistance(i, j, eigenvals);
            const probability = Math.exp(-spectralDistance);
            
            if (probability > 0.3) {
              adjacency[i][j] = adjacency[j][i] = 1;
            }
          }
        }
        
        return adjacency;
      }

      computeSpectralDistance(i, j, eigenvals) {
        // Simplified spectral distance measure
        const n = eigenvals.length;
        let distance = 0;
        
        for (let k = 1; k < Math.min(4, n); k++) {
          const eigenval = eigenvals[k];
          if (eigenval > 1e-6) {
            distance += Math.abs(Math.cos(2 * Math.PI * k * i / n) - 
                               Math.cos(2 * Math.PI * k * j / n)) / eigenval;
          }
        }
        
        return distance;
      }

      computeGraphProperties(eigenvals) {
        const n = eigenvals.length;
        return {
          spectralGap: eigenvals[1] - eigenvals[0],
          algebraicConnectivity: eigenvals[1],
          maxEigenvalue: eigenvals[n - 1],
          eigenvalueSum: eigenvals.reduce((a, b) => a + b, 0)
        };
      }
    }

    // graph-visualizer.js - Canvas-based graph rendering
    class GraphVisualizer {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.setupCanvas();
        this.animationFrame = null;
        
        // Visual settings
        this.nodeRadius = 12;
        this.nodeColor = '#6366f1';
        this.nodeStroke = '#ffffff';
        this.edgeColor = '#cbd5e1';
        this.edgeWidth = 2;
        this.selectedColor = '#ec4899';
        
        // Interaction
        this.isDragging = false;
        this.dragNode = null;
        this.mousePos = { x: 0, y: 0 };
        
        this.setupInteraction();
      }

      setupCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
      }

      setupInteraction() {
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
        this.canvas.addEventListener('mouseleave', () => this.handleMouseUp());
      }

      handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.mousePos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };

        if (this.graph) {
          const clickedNode = this.getNodeAtPosition(this.mousePos);
          if (clickedNode !== -1) {
            this.isDragging = true;
            this.dragNode = clickedNode;
          }
        }
      }

      handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.mousePos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };

        if (this.isDragging && this.dragNode !== null && this.graph) {
          this.graph.positions[this.dragNode] = { ...this.mousePos };
          this.render();
        }
      }

      handleMouseUp() {
        this.isDragging = false;
        this.dragNode = null;
      }

      getNodeAtPosition(pos) {
        if (!this.graph) return -1;
        
        for (let i = 0; i < this.graph.positions.length; i++) {
          const node = this.graph.positions[i];
          const dx = pos.x - node.x;
          const dy = pos.y - node.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= this.nodeRadius + 5) {
            return i;
          }
        }
        
        return -1;
      }

      setGraph(graph) {
        this.graph = graph;
        this.render();
      }

      render() {
        if (!this.graph) return;

        const ctx = this.ctx;
        const rect = this.canvas.getBoundingClientRect();
        
        // Clear canvas
        ctx.clearRect(0, 0, rect.width, rect.height);
        
        // Draw edges
        this.drawEdges();
        
        // Draw nodes
        this.drawNodes();
        
        // Draw labels
        this.drawLabels();
      }

      drawEdges() {
        const ctx = this.ctx;
        const { positions, adjacency } = this.graph;
        
        ctx.strokeStyle = this.edgeColor;
        ctx.lineWidth = this.edgeWidth;
        
        for (let i = 0; i < positions.length; i++) {
          for (let j = i + 1; j < positions.length; j++) {
            if (adjacency[i][j]) {
              ctx.beginPath();
              ctx.moveTo(positions[i].x, positions[i].y);
              ctx.lineTo(positions[j].x, positions[j].y);
              ctx.stroke();
            }
          }
        }
      }

      drawNodes() {
        const ctx = this.ctx;
        const { positions } = this.graph;
        
        positions.forEach((pos, i) => {
          const isHovered = this.getNodeAtPosition(this.mousePos) === i;
          const isDragged = this.dragNode === i;
          
          // Node shadow
          ctx.beginPath();
          ctx.arc(pos.x + 2, pos.y + 2, this.nodeRadius, 0, 2 * Math.PI);
          ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
          ctx.fill();
          
          // Node body
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, this.nodeRadius, 0, 2 * Math.PI);
          ctx.fillStyle = (isHovered || isDragged) ? this.selectedColor : this.nodeColor;
          ctx.fill();
          
          // Node border
          ctx.strokeStyle = this.nodeStroke;
          ctx.lineWidth = 3;
          ctx.stroke();
        });
      }

      drawLabels() {
        const ctx = this.ctx;
        const { positions } = this.graph;
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 10px Inter';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        positions.forEach((pos, i) => {
          ctx.fillText(i.toString(), pos.x, pos.y);
        });
      }

      updateProperties(properties) {
        document.getElementById('spectral-gap').textContent = 
          properties.spectralGap.toFixed(3);
        document.getElementById('algebraic-connectivity').textContent = 
          properties.algebraicConnectivity.toFixed(3);
      }
    }

    // eigenvalue-controls.js - Interactive UI components
    class EigenvalueControls {
      constructor(container, onChange) {
        this.container = container;
        this.onChange = onChange;
        this.nodeCount = 5;
        this.eigenvalues = [0, 0.5, 1.0, 1.5, 2.0];
        this.setupControls();
      }

      setupControls() {
        this.renderSliders();
        this.setupPresets();
        this.setupNodeCountControl();
      }

      renderSliders() {
        this.container.innerHTML = '';
        
        this.eigenvalues.forEach((value, index) => {
          const controlDiv = document.createElement('div');
          controlDiv.className = 'eigenvalue-control';
          
          controlDiv.innerHTML = `
            <div class="eigenvalue-label">
              <span>Î»${index + 1}</span>
              <span class="eigenvalue-value">${value.toFixed(3)}</span>
            </div>
            <input type="range" 
                   class="eigenvalue-slider" 
                   id="eigenvalue-${index}"
                   min="0" 
                   max="5" 
                   step="0.01" 
                   value="${value}"
                   ${index === 0 ? 'disabled' : ''}>
          `;
          
          this.container.appendChild(controlDiv);
          
          const slider = controlDiv.querySelector('.eigenvalue-slider');
          const valueSpan = controlDiv.querySelector('.eigenvalue-value');
          
          slider.addEventListener('input', (e) => {
            const newValue = parseFloat(e.target.value);
            this.eigenvalues[index] = newValue;
            valueSpan.textContent = newValue.toFixed(3);
            this.onChange(this.eigenvalues);
          });
        });
      }

      setupPresets() {
        const presetButtons = document.querySelectorAll('.preset-btn');
        presetButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const preset = btn.dataset.preset;
            const engine = new GraphLaplacianEngine();
            this.eigenvalues = engine.getPresetEigenvalues(preset, this.nodeCount);
            this.updateSliders();
            this.onChange(this.eigenvalues);
          });
        });
      }

      setupNodeCountControl() {
        const nodeCountSelect = document.getElementById('node-count');
        nodeCountSelect.addEventListener('change', (e) => {
          this.nodeCount = parseInt(e.target.value);
          this.eigenvalues = new Array(this.nodeCount).fill(0).map((_, i) => i * 0.5);
          this.renderSliders();
          this.onChange(this.eigenvalues);
        });
      }

      updateSliders() {
        this.eigenvalues.forEach((value, index) => {
          const slider = document.getElementById(`eigenvalue-${index}`);
          const valueSpan = slider.parentElement.querySelector('.eigenvalue-value');
          if (slider) {
            slider.value = value;
            valueSpan.textContent = value.toFixed(3);
          }
        });
      }

      setEigenvalues(eigenvalues) {
        this.eigenvalues = [...eigenvalues];
        this.updateSliders();
      }
    }

    // main-applet.js - Orchestration and state management
    class GraphLaplacianApplet {
      constructor() {
        this.engine = new GraphLaplacianEngine();
        this.visualizer = null;
        this.controls = null;
        this.currentGraph = null;
        this.worker = null;
        
        this.init();
      }

      async init() {
        // Setup visualizer
        const canvas = document.getElementById('graph-canvas');
        this.visualizer = new GraphVisualizer(canvas);
        
        // Setup intuitive property controls instead of raw eigenvalue controls
        this.controls = new PropertyControls(
          document.querySelector('.controls-panel'), 
          (eigenvalues) => this.onEigenvaluesChanged(eigenvalues)
        );
        
        // Setup worker for heavy computations
        this.setupWorker();
        
        // Initial graph - start with a simple path to demonstrate
        this.generateInitialGraph();
        
        // Handle window resize
        window.addEventListener('resize', () => {
          this.visualizer.setupCanvas();
          this.visualizer.render();
        });
      }

      setupWorker() {
        // For this demo, we'll compute synchronously
        // In production, use Web Workers for heavy computations
        this.worker = {
          postMessage: (data) => {
            setTimeout(() => {
              const result = this.engine.generateGraphFromEigenvalues(data.eigenvalues);
              this.onWorkerMessage({ data: result });
            }, 50);
          }
        };
      }

      onWorkerMessage(event) {
        const graph = event.data;
        this.currentGraph = graph;
        this.visualizer.setGraph(graph);
        this.visualizer.updateProperties(graph.properties);
        
        // Update the explanation based on what we're showing
        this.updateDynamicExplanation(graph);
      }

      updateDynamicExplanation(graph) {
        const explanationEl = document.getElementById('explanation-text');
        const properties = this.controls.getProperties();
        const { spectralGap, algebraicConnectivity } = graph.properties;
        
        let explanation = `Your ${this.getGraphDescription(graph)} has `;
        
        if (algebraicConnectivity > 2.0) {
          explanation += "excellent connectivity - information flows quickly between all nodes. ";
        } else if (algebraicConnectivity > 1.0) {
          explanation += "good connectivity - most nodes can communicate efficiently. ";
        } else if (algebraicConnectivity > 0.3) {
          explanation += "moderate connectivity - some bottlenecks may exist. ";
        } else {
          explanation += "limited connectivity - the graph may have weak points. ";
        }
        
        explanation += `The spectral gap of ${spectralGap.toFixed(2)} indicates ${
          spectralGap > 1.0 ? "rapid mixing and strong connectivity" : "slower information propagation"
        }.`;
        
        explanationEl.innerHTML = explanation;
      }

      getGraphDescription(graph) {
        const validation = this.engine.validateEigenvalues(graph.eigenvalues);
        if (validation.valid && validation.graphType && validation.confidence > 0.9) {
          const typeNames = {
            path: "chain of connected nodes",
            cycle: "circular ring network", 
            complete: "fully connected network",
            star: "hub-and-spoke network"
          };
          return typeNames[validation.graphType] || "network";
        }
        return "network";
      }

      generateInitialGraph() {
        // Start with a path graph with moderate connectivity
        this.controls.setProperties({ connectivity: 25, expansion: 60, clustering: 10 });
      }

      onEigenvaluesChanged(eigenvalues) {
        // Generate graph (via worker in production)
        this.worker.postMessage({ eigenvalues });
      }
    }

    // Initialize the applet
    document.addEventListener('DOMContentLoaded', () => {
      const applet = new GraphLaplacianApplet();
      window.graphLaplacianApplet = applet; // For debugging
    });
  </script>
</body>
</html>