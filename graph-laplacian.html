<!-- graph-laplacian.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Interactive visualization of graph Laplacian eigenvalues and their effect on graph structure">
  <title>Graph Laplacian Eigenvalue Visualizer — Jack Kinney</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <style>
    /* CSS Variables matching your existing theme */
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --primary-light: #a5b4fc;
      --secondary: #ec4899;
      --accent: #f59e0b;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;

      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-tertiary: #e2e8f0;
      --bg-card: #ffffff;
      --bg-card-hover: #f1f5f9;

      --text-primary: #0f172a;
      --text-secondary: #475569;
      --text-muted: #64748b;

      --border: #e2e8f0;
      --border-light: #cbd5e1;

      --space-1: 0.25rem;
      --space-2: 0.5rem;
      --space-3: 0.75rem;
      --space-4: 1rem;
      --space-6: 1.5rem;
      --space-8: 2rem;
      --space-12: 3rem;
      --space-16: 4rem;

      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --font-mono: 'JetBrains Mono', 'SF Mono', 'Monaco', 'Consolas', monospace;

      --radius: 0.5rem;
      --radius-lg: 1rem;
      --radius-xl: 1.5rem;

      --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
      --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1);

      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-sans);
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      min-height: 100vh;
    }

    .container {
      width: 100%;
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 var(--space-6);
    }

    /* Header */
    .header {
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border);
      padding: var(--space-4) 0;
      position: sticky;
      top: 0;
      z-index: 100;
      backdrop-filter: blur(20px);
    }

    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--text-primary);
      font-family: var(--font-mono);
      text-decoration: none;
    }

    .back-link {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      color: var(--primary);
      text-decoration: none;
      font-weight: 500;
      transition: var(--transition);
    }

    .back-link:hover {
      color: var(--primary-dark);
    }

    /* Main Layout */
    .main-content {
      padding: var(--space-8) 0;
    }

    .app-header {
      text-align: center;
      margin-bottom: var(--space-12);
    }

    .app-title {
      font-size: 2.5rem;
      font-weight: 800;
      margin-bottom: var(--space-4);
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .app-description {
      font-size: 1.125rem;
      color: var(--text-secondary);
      max-width: 800px;
      margin: 0 auto;
    }

    /* App Layout */
    .app-container {
      display: grid;
      grid-template-columns: 350px 1fr;
      gap: var(--space-8);
      min-height: 600px;
    }

    .controls-panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      padding: var(--space-6);
      height: fit-content;
      position: sticky;
      top: 120px;
      box-shadow: var(--shadow-lg);
    }

    .visualization-panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      padding: var(--space-6);
      box-shadow: var(--shadow-lg);
    }

    /* Controls */
    .control-section {
      margin-bottom: var(--space-6);
    }

    .control-section:last-child {
      margin-bottom: 0;
    }

    .section-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: var(--space-4);
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .eigenvalue-control.snapped {
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid var(--success);
      border-radius: var(--radius);
      transform: scale(1.02);
      transition: all 0.3s ease;
    }

    .snap-tooltip {
      position: absolute;
      top: -35px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--success);
      color: white;
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius);
      font-size: 0.75rem;
      white-space: nowrap;
      z-index: 1000;
      animation: fadeInOut 1s ease;
    }

    .snap-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 4px solid transparent;
      border-top-color: var(--success);
    }

    @keyframes fadeInOut {
      0%, 100% { opacity: 0; transform: translateX(-50%) translateY(-5px); }
      20%, 80% { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Property Controls */
    .property-control {
      margin-bottom: var(--space-6);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-4);
      transition: var(--transition);
    }

    .property-control:hover {
      border-color: var(--primary);
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.1);
    }

    .property-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--space-3);
      font-weight: 600;
      color: var(--text-primary);
    }

    .property-label i {
      color: var(--text-muted);
      cursor: help;
    }

    .property-slider-container {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      margin-bottom: var(--space-2);
    }

    .property-slider {
      flex: 1;
      height: 8px;
      border-radius: 4px;
      background: var(--bg-tertiary);
      outline: none;
      transition: var(--transition);
      -webkit-appearance: none;
    }

    .property-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      transition: var(--transition);
    }

    .property-slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
    }

    .property-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    .slider-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      white-space: nowrap;
      font-weight: 500;
    }

    .property-value {
      text-align: center;
      font-size: 0.875rem;
      color: var(--primary);
      font-weight: 500;
      background: rgba(99, 102, 241, 0.1);
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius);
    }

    .help-text {
      font-size: 0.875rem;
      color: var(--text-muted);
      margin-bottom: var(--space-4);
      line-height: 1.5;
      font-style: italic;
    }

    .setting-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-3);
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .setting-label select {
      padding: var(--space-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: inherit;
    }

    .advanced-toggle {
      margin-top: var(--space-4);
    }

    .advanced-toggle label {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      font-size: 0.875rem;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .advanced-toggle input[type="checkbox"] {
      transform: scale(1.2);
      accent-color: var(--primary);
    }

    .advanced-section {
      border-top: 1px solid var(--border);
      padding-top: var(--space-6);
      margin-top: var(--space-6);
    }

    .explanation {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(236, 72, 153, 0.1));
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: var(--radius);
      padding: var(--space-4);
      font-size: 0.875rem;
      line-height: 1.6;
      color: var(--text-secondary);
      position: relative;
      overflow: hidden;
    }

    .explanation::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: linear-gradient(180deg, var(--primary), var(--secondary));
    }

    #eigenvalue-display {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
      font-family: var(--font-mono);
      font-size: 0.8rem;
      max-height: 150px;
      overflow-y: auto;
    }

    .eigenvalue-item {
      display: flex;
      justify-content: space-between;
      padding: var(--space-1) 0;
      border-bottom: 1px solid var(--border);
    }

    .eigenvalue-item:last-child {
      border-bottom: none;
    }

    .eigenvalue-item .label {
      color: var(--text-muted);
    }

    .eigenvalue-item .value {
      color: var(--primary);
      font-weight: 500;
    }

    /* Analysis Tabs */
    .analysis-tabs {
      display: flex;
      gap: var(--space-1);
      margin: var(--space-6) 0 var(--space-4) 0;
      border-bottom: 2px solid var(--border);
    }

    .tab-btn {
      padding: var(--space-3) var(--space-4);
      background: none;
      border: none;
      border-bottom: 3px solid transparent;
      color: var(--text-muted);
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
      font-family: inherit;
      font-size: 0.875rem;
    }

    .tab-btn:hover {
      color: var(--text-primary);
      background: var(--bg-secondary);
    }

    .tab-btn.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
      background: var(--bg-secondary);
    }

    .tab-content {
      min-height: 300px;
    }

    .tab-panel {
      display: none;
      animation: fadeIn 0.3s ease;
    }

    .tab-panel.active {
      display: block;
    }

    .panel-header {
      margin-bottom: var(--space-4);
    }

    .panel-header h4 {
      margin-bottom: var(--space-2);
      color: var(--text-primary);
    }

    .panel-header p {
      color: var(--text-muted);
      font-size: 0.875rem;
    }

    /* Eigenvalue Chart */
    .eigenvalue-chart {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-4);
      margin-bottom: var(--space-4);
      display: flex;
      justify-content: center;
    }

    .eigenvalue-insights {
      display: grid;
      gap: var(--space-2);
    }

    .insight-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-2) var(--space-3);
      background: var(--bg-secondary);
      border-radius: var(--radius);
      font-size: 0.875rem;
    }

    .insight-label {
      color: var(--text-secondary);
      font-weight: 500;
    }

    .insight-value {
      color: var(--primary);
      font-weight: 600;
    }

    /* Eigenvector Controls */
    .eigenvector-controls {
      display: flex;
      align-items: center;
      gap: var(--space-4);
      margin-bottom: var(--space-4);
      padding: var(--space-3);
      background: var(--bg-secondary);
      border-radius: var(--radius);
    }

    .eigenvector-controls label {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      font-size: 0.875rem;
    }

    .eigenvector-controls select {
      padding: var(--space-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    .animation-btn {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-3);
      background: var(--primary);
      color: white;
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 0.875rem;
      transition: var(--transition);
    }

    .animation-btn:hover {
      background: var(--primary-dark);
      transform: translateY(-1px);
    }

    .eigenvector-explanation {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(16, 185, 129, 0.1));
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: var(--radius);
      padding: var(--space-4);
      font-size: 0.875rem;
      line-height: 1.6;
      color: var(--text-secondary);
    }

    /* Learning Section */
    .learning-section {
      max-height: 400px;
      overflow-y: auto;
      padding-right: var(--space-2);
    }

    .learning-section h4 {
      margin-bottom: var(--space-4);
      color: var(--text-primary);
      text-align: center;
      font-size: 1.25rem;
    }

    .concept-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--space-4);
      margin-bottom: var(--space-4);
      transition: var(--transition);
    }

    .concept-card:hover {
      border-color: var(--primary);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.1);
    }

    .concept-card.highlight {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(236, 72, 153, 0.1));
      border-color: var(--primary);
    }

    .concept-header {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      margin-bottom: var(--space-3);
    }

    .concept-header i {
      font-size: 1.25rem;
      color: var(--primary);
      width: 24px;
      text-align: center;
    }

    .concept-header h5 {
      margin: 0;
      color: var(--text-primary);
      font-size: 1rem;
    }

    .concept-card p {
      margin-bottom: var(--space-3);
      line-height: 1.6;
    }

    .concept-card ul {
      margin: 0;
      padding-left: var(--space-4);
    }

    .concept-card li {
      margin-bottom: var(--space-2);
      line-height: 1.5;
    }

    .concept-card li strong {
      color: var(--primary);
    }

    /* Custom scrollbar for learning section */
    .learning-section::-webkit-scrollbar {
      width: 6px;
    }

    .learning-section::-webkit-scrollbar-track {
      background: var(--bg-tertiary);
      border-radius: 3px;
    }

    .learning-section::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 3px;
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .eigenvalue-label {
      display: flex;
      justify-content: between;
      align-items: center;
      margin-bottom: var(--space-2);
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .eigenvalue-slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--bg-tertiary);
      outline: none;
      transition: var(--transition);
      -webkit-appearance: none;
    }

    .eigenvalue-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: var(--shadow);
    }

    .eigenvalue-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: var(--shadow);
    }

    .preset-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-3);
    }

    .preset-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    .preset-btn {
      padding: var(--space-2) var(--space-3);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      color: var(--text-primary);
      font-size: 0.875rem;
      cursor: pointer;
      transition: var(--transition);
      font-family: inherit;
      position: relative;
      overflow: hidden;
    }

    .preset-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }

    .preset-btn:hover::before {
      left: 100%;
    }

    /* Remove old status display styles - replaced with integrated explanations */

    /* Canvas */
    .canvas-container {
      position: relative;
      width: 100%;
      height: 600px;
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      overflow: hidden;
      background: linear-gradient(45deg, #f8fafc 25%, transparent 25%), 
                  linear-gradient(-45deg, #f8fafc 25%, transparent 25%), 
                  linear-gradient(45deg, transparent 75%, #f8fafc 75%), 
                  linear-gradient(-45deg, transparent 75%, #f8fafc 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }

    #graph-canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #graph-canvas:active {
      cursor: grabbing;
    }

    .canvas-overlay {
      position: absolute;
      top: var(--space-4);
      right: var(--space-4);
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
      font-size: 0.875rem;
      backdrop-filter: blur(10px);
    }

    /* Info Panel */
    .info-panel {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--space-4);
      margin-top: var(--space-6);
    }

    .info-title {
      font-weight: 600;
      margin-bottom: var(--space-2);
      color: var(--text-primary);
    }

    .info-text {
      font-size: 0.875rem;
      color: var(--text-secondary);
      line-height: 1.6;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .app-container {
        grid-template-columns: 1fr;
        gap: var(--space-6);
      }

      .controls-panel {
        position: static;
        order: 2;
      }

      .preset-buttons {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 0 var(--space-4);
      }

      .app-title {
        font-size: 2rem;
      }

      .canvas-container {
        height: 400px;
      }

      .preset-buttons {
        grid-template-columns: 1fr 1fr;
      }
    }

    /* Loading Animation */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 200px;
      color: var(--text-muted);
      font-size: 0.875rem;
    }

    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-top: 2px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: var(--space-2);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="container">
      <div class="header-content">
        <a href="./index.html" class="logo">&lt;JTK/&gt;</a>
        <a href="./projects.html" class="back-link">
          <i class="fas fa-arrow-left"></i>
          Back to Projects
        </a>
      </div>
    </div>
  </header>

  <main class="main-content">
    <div class="container">
      <div class="app-header">
        <h1 class="app-title">Graph Laplacian Eigenvalue Visualizer</h1>
        <p class="app-description">
          Discover how graph connectivity, clustering, and spread affect network structure! 
          Adjust intuitive properties and watch as the mathematical eigenvalues automatically 
          update to create valid graph configurations. No spectral graph theory knowledge required.
        </p>
      </div>

      <div class="app-container">
        <div class="controls-panel">
          <div class="control-section">
            <h3 class="section-title">
              <i class="fas fa-network-wired"></i>
              Graph Properties
            </h3>
            <div class="help-text">
              Adjust how connected and clustered your graph is. The math happens automatically!
            </div>
            
            <div class="property-control">
              <div class="property-label">
                <span>How Connected?</span>
                <i class="fas fa-question-circle" title="Higher values create more tightly connected graphs"></i>
              </div>
              <div class="property-slider-container">
                <span class="slider-label">Sparse</span>
                <input type="range" class="property-slider" id="connectivity-slider" 
                       min="0" max="100" value="30" data-property="connectivity">
                <span class="slider-label">Dense</span>
              </div>
              <div class="property-value">Low connectivity</div>
            </div>

            <div class="property-control">
              <div class="property-label">
                <span>How Spread Out?</span>
                <i class="fas fa-question-circle" title="Controls how far apart different parts of the graph are"></i>
              </div>
              <div class="property-slider-container">
                <span class="slider-label">Tight</span>
                <input type="range" class="property-slider" id="expansion-slider" 
                       min="0" max="100" value="60" data-property="expansion">
                <span class="slider-label">Spread</span>
              </div>
              <div class="property-value">Balanced spread</div>
            </div>

            <div class="property-control">
              <div class="property-label">
                <span>How Clustered?</span>
                <i class="fas fa-question-circle" title="Higher values create more distinct groups or clusters"></i>
              </div>
              <div class="property-slider-container">
                <span class="slider-label">Uniform</span>
                <input type="range" class="property-slider" id="clustering-slider" 
                       min="0" max="100" value="15" data-property="clustering">
                <span class="slider-label">Clustered</span>
              </div>
              <div class="property-value">Very low clustering</div>
            </div>
          </div>

          <div class="control-section">
            <h3 class="section-title">
              <i class="fas fa-shapes"></i>
              Common Examples
            </h3>
            <div class="help-text">
              Try these classic graph types to see how properties change
            </div>
            <div class="preset-buttons">
              <button class="preset-btn" data-preset="path" title="Nodes in a line">
                <i class="fas fa-minus"></i> Chain
              </button>
              <button class="preset-btn" data-preset="cycle" title="Nodes in a circle">
                <i class="fas fa-circle-notch"></i> Ring
              </button>
              <button class="preset-btn" data-preset="star" title="One center, many spokes">
                <i class="fas fa-star"></i> Star
              </button>
              <button class="preset-btn" data-preset="complete" title="Everyone connected to everyone">
                <i class="fas fa-project-diagram"></i> Complete
              </button>
            </div>
          </div>

          <div class="control-section">
            <h3 class="section-title">
              <i class="fas fa-cog"></i>
              Settings
            </h3>
            <label class="setting-label">
              <span>Number of nodes:</span>
              <select id="node-count">
                <option value="4">4 nodes</option>
                <option value="5" selected>5 nodes</option>
                <option value="6">6 nodes</option>
                <option value="7">7 nodes</option>
                <option value="8">8 nodes</option>
              </select>
            </label>
            
            <div class="advanced-toggle">
              <label>
                <input type="checkbox" id="show-advanced"> 
                Show eigenvalue details
              </label>
            </div>
          </div>

          <div class="control-section advanced-section" style="display: none;">
            <h3 class="section-title">
              <i class="fas fa-calculator"></i>
              Mathematical Details
            </h3>
            <div class="help-text">
              The eigenvalues that make your graph possible (auto-calculated)
            </div>
            <div id="eigenvalue-display">
              <!-- Eigenvalues shown as read-only information -->
            </div>
          </div>

          <div class="control-section">
            <h3 class="section-title">
              <i class="fas fa-lightbulb"></i>
              What You're Seeing
            </h3>
            <div id="explanation-text" class="explanation">
              Drag the sliders above to see how different properties affect your graph's structure!
            </div>
          </div>
        </div>

        <div class="visualization-panel">
          <div class="canvas-container">
            <canvas id="graph-canvas"></canvas>
            <div class="canvas-overlay">
              <div><strong>Network Health:</strong> <span id="spectral-gap">0.00</span></div>
              <div><strong>Connection Strength:</strong> <span id="algebraic-connectivity">0.00</span></div>
              <div style="font-size: 0.75rem; margin-top: 0.5rem; opacity: 0.8;">
                Higher values = better connectivity
              </div>
            </div>
          </div>

          <div class="analysis-tabs">
            <button class="tab-btn active" data-tab="eigenvalues">Eigenvalue Spectrum</button>
            <button class="tab-btn" data-tab="eigenvectors">Vibration Patterns</button>
            <button class="tab-btn" data-tab="learn">Learn Spectral Theory</button>
          </div>

          <div class="tab-content">
            <!-- Eigenvalue Distribution Plot -->
            <div class="tab-panel active" id="eigenvalues-panel">
              <div class="panel-header">
                <h4>Eigenvalue Distribution</h4>
                <p>Each bar represents an eigenvalue - the mathematical "fingerprint" of your graph</p>
              </div>
              <div class="eigenvalue-chart">
                <canvas id="eigenvalue-chart" width="500" height="200"></canvas>
              </div>
              <div class="eigenvalue-insights">
                <div class="insight-item">
                  <span class="insight-label">First eigenvalue (λ₁):</span>
                  <span class="insight-value">Always 0 for connected graphs</span>
                </div>
                <div class="insight-item">
                  <span class="insight-label">Second eigenvalue (λ₂):</span>
                  <span class="insight-value" id="second-eigenvalue-meaning">Shows connectivity strength</span>
                </div>
                <div class="insight-item">
                  <span class="insight-label">Largest eigenvalue:</span>
                  <span class="insight-value" id="largest-eigenvalue-meaning">Related to maximum degree</span>
                </div>
              </div>
            </div>

            <!-- Eigenvector Visualization -->
            <div class="tab-panel" id="eigenvectors-panel">
              <div class="panel-header">
                <h4>Vibration Patterns (Eigenvectors)</h4>
                <p>Each pattern shows how energy or information flows through your network</p>
              </div>
              <div class="eigenvector-controls">
                <label>
                  <span>Pattern to show:</span>
                  <select id="eigenvector-select">
                    <option value="1">Pattern 2 (Connectivity)</option>
                    <option value="2">Pattern 3 (Clustering)</option>
                    <option value="3">Pattern 4 (Higher Order)</option>
                  </select>
                </label>
                <button id="animate-pattern" class="animation-btn">
                  <i class="fas fa-play"></i> Animate Flow
                </button>
              </div>
              <div class="eigenvector-explanation" id="eigenvector-explanation">
                Select a pattern above to see how it divides and connects your network
              </div>
            </div>

            <!-- Educational Content -->
            <div class="tab-panel" id="learn-panel">
              <div class="learning-section">
                <h4>What is Spectral Graph Theory?</h4>
                <div class="concept-card">
                  <div class="concept-header">
                    <i class="fas fa-lightbulb"></i>
                    <h5>The Big Idea</h5>
                  </div>
                  <p>
                    Imagine your graph as a musical instrument. Just like a guitar string has natural frequencies 
                    it vibrates at, every graph has natural "eigenvalues" and "eigenvectors" that describe how 
                    information, energy, or influence flows through the network.
                  </p>
                </div>

                <div class="concept-card">
                  <div class="concept-header">
                    <i class="fas fa-wave-square"></i>
                    <h5>Eigenvalues: The Network's Fingerprint</h5>
                  </div>
                  <p>
                    <strong>Eigenvalues</strong> are numbers that capture essential properties of your graph:
                  </p>
                  <ul>
                    <li><strong>λ₁ = 0:</strong> Always zero for connected graphs (tells us about components)</li>
                    <li><strong>λ₂ (Algebraic Connectivity):</strong> How well-connected the graph is overall</li>
                    <li><strong>Higher λs:</strong> Reveal clustering, bottlenecks, and structural patterns</li>
                    <li><strong>λₙ (Largest):</strong> Related to how "hub-like" the most connected nodes are</li>
                  </ul>
                </div>

                <div class="concept-card">
                  <div class="concept-header">
                    <i class="fas fa-broadcast-tower"></i>
                    <h5>Eigenvectors: Vibration Patterns</h5>
                  </div>
                  <p>
                    <strong>Eigenvectors</strong> show patterns of how things flow through your network:
                  </p>
                  <ul>
                    <li><strong>Second eigenvector:</strong> Splits the graph into natural communities</li>
                    <li><strong>Higher eigenvectors:</strong> Reveal more complex flow patterns and structures</li>
                    <li><strong>Node colors:</strong> Show positive/negative values - like "hot" and "cold" regions</li>
                    <li><strong>Zero crossings:</strong> Natural boundaries where the network wants to split</li>
                  </ul>
                </div>

                <div class="concept-card">
                  <div class="concept-header">
                    <i class="fas fa-rocket"></i>
                    <h5>Why Spectral Theory is Powerful</h5>
                  </div>
                  <p>
                    Standard graph theory looks at local properties (edges, neighbors). Spectral theory reveals 
                    <strong>global properties</strong> that emerge from the entire network structure:
                  </p>
                  <ul>
                    <li><strong>Community Detection:</strong> Automatically find natural groups</li>
                    <li><strong>Graph Clustering:</strong> Partition networks optimally</li>
                    <li><strong>Random Walks:</strong> Predict how things spread through networks</li>
                    <li><strong>Network Robustness:</strong> Identify critical connections and vulnerabilities</li>
                    <li><strong>Dimensionality Reduction:</strong> Embed graphs in lower dimensions</li>
                  </ul>
                </div>

                <div class="concept-card">
                  <div class="concept-header">
                    <i class="fas fa-cogs"></i>
                    <h5>Real-World Applications</h5>
                  </div>
                  <p>
                    Spectral graph theory powers algorithms you use every day:
                  </p>
                  <ul>
                    <li><strong>Google's PageRank:</strong> Uses the dominant eigenvector to rank web pages</li>
                    <li><strong>Social Media:</strong> Friend recommendations and community detection</li>
                    <li><strong>Machine Learning:</strong> Spectral clustering for data analysis</li>
                    <li><strong>Neuroscience:</strong> Understanding brain connectivity patterns</li>
                    <li><strong>Computer Graphics:</strong> Mesh processing and shape analysis</li>
                    <li><strong>Quantum Computing:</strong> Quantum walks and optimization algorithms</li>
                  </ul>
                </div>

                <div class="concept-card highlight">
                  <div class="concept-header">
                    <i class="fas fa-magic"></i>
                    <h5>The Magic of Linear Algebra</h5>
                  </div>
                  <p>
                    By representing graphs as matrices, we unlock the full power of linear algebra. 
                    Properties that would require complex algorithms to compute directly can be 
                    read off immediately from eigenvalues and eigenvectors. It's like having 
                    X-ray vision for network structure!
                  </p>
                </div>
              </div>
            </div>
          </div>

          <div class="info-panel">
            <div class="info-title">Experiment and Explore!</div>
            <div class="info-text">
              Try adjusting the properties above and watch how the eigenvalue spectrum changes. 
              Notice how different network types have characteristic "fingerprints" in their eigenvalues.
              Switch to the vibration patterns to see how information naturally flows through your network.
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    // graph-laplacian-engine.js - Core mathematical operations
    class GraphLaplacianEngine {
      constructor() {
        this.tolerance = 1e-10;
        this.maxIterations = 1000;
      }

      // Generate eigenvalues for common graph types
      getPresetEigenvalues(type, n) {
        switch(type) {
          case 'path':
            return this.pathGraphEigenvalues(n);
          case 'cycle':
            return this.cycleGraphEigenvalues(n);
          case 'complete':
            return this.completeGraphEigenvalues(n);
          case 'star':
            return this.starGraphEigenvalues(n);
          case 'wheel':
            return this.wheelGraphEigenvalues(n);
          case 'random':
            return this.randomValidEigenvalues(n);
          default:
            return new Array(n).fill(0).map((_, i) => i);
        }
      }

      pathGraphEigenvalues(n) {
        const eigenvals = [0]; // First eigenvalue is always 0
        for (let k = 1; k < n; k++) {
          eigenvals.push(2 - 2 * Math.cos((k * Math.PI) / (n + 1)));
        }
        return eigenvals.sort((a, b) => a - b);
      }

      cycleGraphEigenvalues(n) {
        const eigenvals = [];
        for (let k = 0; k < n; k++) {
          eigenvals.push(2 - 2 * Math.cos((2 * Math.PI * k) / n));
        }
        return eigenvals.sort((a, b) => a - b);
      }

      completeGraphEigenvalues(n) {
        const eigenvals = [0];
        for (let i = 1; i < n; i++) {
          eigenvals.push(n);
        }
        return eigenvals;
      }

      starGraphEigenvalues(n) {
        const eigenvals = [0, 1];
        for (let i = 2; i < n; i++) {
          eigenvals.push(1);
        }
        eigenvals[n - 1] = n;
        return eigenvals.sort((a, b) => a - b);
      }

      wheelGraphEigenvalues(n) {
        // Wheel graph: cycle + center node
        const cycleEigenvals = this.cycleGraphEigenvalues(n - 1);
        return [0, ...cycleEigenvals.slice(1).map(x => x + 1), n];
      }

      randomValidEigenvalues(n) {
        // Generate random but valid eigenvalue set
        const eigenvals = [0]; // Always start with 0
        for (let i = 1; i < n; i++) {
          eigenvals.push(Math.random() * 4 + 0.1);
        }
        return eigenvals.sort((a, b) => a - b);
      }

      // Check if eigenvalues are valid for a graph
      validateEigenvalues(eigenvals) {
        const n = eigenvals.length;
        
        // Basic checks
        if (Math.abs(eigenvals[0]) > this.tolerance) {
          return { valid: false, reason: "First eigenvalue must be 0 (connected components)" };
        }

        for (let i = 0; i < n - 1; i++) {
          if (eigenvals[i] > eigenvals[i + 1] + this.tolerance) {
            return { valid: false, reason: "Eigenvalues must be in non-decreasing order" };
          }
        }

        // Check for disconnected graph (multiple zero eigenvalues)
        let zeroCount = 0;
        for (let i = 0; i < n; i++) {
          if (Math.abs(eigenvals[i]) < this.tolerance) zeroCount++;
        }
        
        if (zeroCount > 1) {
          return { valid: false, reason: `Graph has ${zeroCount} connected components` };
        }

        // Check algebraic connectivity
        if (eigenvals[1] < this.tolerance && n > 1) {
          return { valid: false, reason: "Graph is disconnected (algebraic connectivity = 0)" };
        }

        // Advanced checks: interlacing properties and realizability
        const confidence = this.computeConfidence(eigenvals);
        const realizability = this.checkRealizability(eigenvals);
        
        if (realizability.realizable) {
          return { valid: true, confidence, graphType: realizability.graphType };
        } else {
          return { 
            valid: false, 
            reason: realizability.reason,
            confidence: confidence * 0.5 // Partially valid but not realizable
          };
        }
      }

      checkRealizability(eigenvals) {
        const n = eigenvals.length;
        
        // Check against known graph families
        const tolerance = 0.05;
        
        // Path graph check
        const pathEigenvals = this.pathGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, pathEigenvals, tolerance)) {
          return { realizable: true, graphType: 'path' };
        }
        
        // Cycle graph check
        const cycleEigenvals = this.cycleGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, cycleEigenvals, tolerance)) {
          return { realizable: true, graphType: 'cycle' };
        }
        
        // Complete graph check
        const completeEigenvals = this.completeGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, completeEigenvals, tolerance)) {
          return { realizable: true, graphType: 'complete' };
        }
        
        // Star graph check
        const starEigenvals = this.starGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, starEigenvals, tolerance)) {
          return { realizable: true, graphType: 'star' };
        }
        
        // General realizability heuristics
        const maxPossibleEigenvalue = 2 * n; // Upper bound for regular graphs
        if (eigenvals[n - 1] > maxPossibleEigenvalue) {
          return { 
            realizable: false, 
            reason: `Max eigenvalue ${eigenvals[n - 1].toFixed(2)} exceeds theoretical bound ${maxPossibleEigenvalue}` 
          };
        }
        
        // Check eigenvalue gaps (very large gaps are suspicious)
        for (let i = 1; i < n - 1; i++) {
          const gap = eigenvals[i + 1] - eigenvals[i];
          if (gap > n) {
            return { 
              realizable: false, 
              reason: `Unusually large eigenvalue gap (${gap.toFixed(2)}) between λ${i+1} and λ${i+2}` 
            };
          }
        }
        
        return { realizable: true, graphType: 'general' };
      }

      eigenvaluesMatch(eigenvals1, eigenvals2, tolerance) {
        if (eigenvals1.length !== eigenvals2.length) return false;
        
        for (let i = 0; i < eigenvals1.length; i++) {
          if (Math.abs(eigenvals1[i] - eigenvals2[i]) > tolerance) return false;
        }
        return true;
      }

      computeConfidence(eigenvals) {
        // Heuristic to determine how "graph-like" the eigenvalues are
        const n = eigenvals.length;
        let score = 1.0;

        // Penalize very large gaps
        for (let i = 1; i < n - 1; i++) {
          const gap = eigenvals[i + 1] - eigenvals[i];
          if (gap > 3) score *= 0.8;
        }

        // Penalize very large eigenvalues
        const maxEigenval = eigenvals[n - 1];
        if (maxEigenval > 2 * n) score *= 0.7;

        return Math.max(0.1, Math.min(1.0, score));
      }

      // Project invalid eigenvalues to nearest valid set
      projectToValidEigenvalues(eigenvals) {
        const projected = [...eigenvals].sort((a, b) => a - b);
        projected[0] = 0; // Ensure first eigenvalue is 0
        
        // Ensure non-negativity
        for (let i = 0; i < projected.length; i++) {
          projected[i] = Math.max(0, projected[i]);
        }

        // Ensure algebraic connectivity > 0 (except for disconnected graphs)
        if (projected.length > 1 && projected[1] < 0.01) {
          projected[1] = 0.1;
        }

        return projected;
      }

      // Generate approximate graph from eigenvalues
      generateGraphFromEigenvalues(eigenvals) {
        const n = eigenvals.length;
        const positions = this.generateSpectralPositions(eigenvals);
        const adjacency = this.constructAdjacencyMatrix(eigenvals, positions);
        
        return {
          positions,
          adjacency,
          eigenvalues: eigenvals,
          properties: this.computeGraphProperties(eigenvals)
        };
      }

      generateSpectralPositions(eigenvals) {
        const n = eigenvals.length;
        const positions = [];
        
        // Use first few eigenvalues to determine 2D embedding
        for (let i = 0; i < n; i++) {
          const angle = (2 * Math.PI * i) / n;
          const radius = 150 + 50 * Math.sin(eigenvals[Math.min(i, eigenvals.length - 1)]);
          
          positions.push({
            x: 300 + radius * Math.cos(angle),
            y: 300 + radius * Math.sin(angle)
          });
        }
        
        return positions;
      }

      constructAdjacencyMatrix(eigenvals, positions) {
        const n = eigenvals.length;
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        
        // Determine graph type based on eigenvalue pattern
        const graphType = this.detectGraphType(eigenvals);
        
        switch(graphType) {
          case 'path':
            return this.createPathAdjacency(n);
          case 'cycle':
            return this.createCycleAdjacency(n);
          case 'complete':
            return this.createCompleteAdjacency(n);
          case 'star':
            return this.createStarAdjacency(n);
          default:
            return this.createHeuristicAdjacency(eigenvals, positions);
        }
      }

      detectGraphType(eigenvals) {
        const n = eigenvals.length;
        const tolerance = 0.1;
        
        // Check for path graph pattern
        const pathEigenvals = this.pathGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, pathEigenvals, tolerance)) return 'path';
        
        // Check for cycle graph pattern  
        const cycleEigenvals = this.cycleGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, cycleEigenvals, tolerance)) return 'cycle';
        
        // Check for complete graph pattern
        const completeEigenvals = this.completeGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, completeEigenvals, tolerance)) return 'complete';
        
        // Check for star graph pattern
        const starEigenvals = this.starGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, starEigenvals, tolerance)) return 'star';
        
        return 'unknown';
      }

      eigenvaluesMatch(eigenvals1, eigenvals2, tolerance) {
        if (eigenvals1.length !== eigenvals2.length) return false;
        
        for (let i = 0; i < eigenvals1.length; i++) {
          if (Math.abs(eigenvals1[i] - eigenvals2[i]) > tolerance) return false;
        }
        return true;
      }

      createPathAdjacency(n) {
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        for (let i = 0; i < n - 1; i++) {
          adjacency[i][i + 1] = adjacency[i + 1][i] = 1;
        }
        return adjacency;
      }

      createCycleAdjacency(n) {
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        for (let i = 0; i < n - 1; i++) {
          adjacency[i][i + 1] = adjacency[i + 1][i] = 1;
        }
        adjacency[0][n - 1] = adjacency[n - 1][0] = 1;
        return adjacency;
      }

      createCompleteAdjacency(n) {
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            adjacency[i][j] = adjacency[j][i] = 1;
          }
        }
        return adjacency;
      }

      createStarAdjacency(n) {
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        // Connect all nodes to node 0 (center)
        for (let i = 1; i < n; i++) {
          adjacency[0][i] = adjacency[i][0] = 1;
        }
        return adjacency;
      }

      createHeuristicAdjacency(eigenvals, positions) {
        const n = eigenvals.length;
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            const spectralDistance = this.computeSpectralDistance(i, j, eigenvals);
            const probability = Math.exp(-spectralDistance);
            
            if (probability > 0.3) {
              adjacency[i][j] = adjacency[j][i] = 1;
            }
          }
        }
        
        return adjacency;
      }

      computeSpectralDistance(i, j, eigenvals) {
        // Simplified spectral distance measure
        const n = eigenvals.length;
        let distance = 0;
        
        for (let k = 1; k < Math.min(4, n); k++) {
          const eigenval = eigenvals[k];
          if (eigenval > 1e-6) {
            distance += Math.abs(Math.cos(2 * Math.PI * k * i / n) - 
                               Math.cos(2 * Math.PI * k * j / n)) / eigenval;
          }
        }
        
        return distance;
      }

      computeGraphProperties(eigenvals) {
        const n = eigenvals.length;
        return {
          spectralGap: eigenvals[1] - eigenvals[0],
          algebraicConnectivity: eigenvals[1],
          maxEigenvalue: eigenvals[n - 1],
          eigenvalueSum: eigenvals.reduce((a, b) => a + b, 0)
        };
      }
    }

    // graph-visualizer.js - Canvas-based graph rendering
    class GraphVisualizer {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.setupCanvas();
        this.animationFrame = null;
        
        // Visual settings
        this.nodeRadius = 12;
        this.nodeColor = '#6366f1';
        this.nodeStroke = '#ffffff';
        this.edgeColor = '#cbd5e1';
        this.edgeWidth = 2;
        this.selectedColor = '#ec4899';
        
        // Interaction
        this.isDragging = false;
        this.dragNode = null;
        this.mousePos = { x: 0, y: 0 };
        
        this.setupInteraction();
      }

      setupCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
      }

      setupInteraction() {
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
        this.canvas.addEventListener('mouseleave', () => this.handleMouseUp());
      }

      handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.mousePos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };

        if (this.graph) {
          const clickedNode = this.getNodeAtPosition(this.mousePos);
          if (clickedNode !== -1) {
            this.isDragging = true;
            this.dragNode = clickedNode;
          }
        }
      }

      handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.mousePos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };

        if (this.isDragging && this.dragNode !== null && this.graph) {
          this.graph.positions[this.dragNode] = { ...this.mousePos };
          this.render();
        }
      }

      handleMouseUp() {
        this.isDragging = false;
        this.dragNode = null;
      }

      getNodeAtPosition(pos) {
        if (!this.graph) return -1;
        
        for (let i = 0; i < this.graph.positions.length; i++) {
          const node = this.graph.positions[i];
          const dx = pos.x - node.x;
          const dy = pos.y - node.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= this.nodeRadius + 5) {
            return i;
          }
        }
        
        return -1;
      }

      setGraph(graph) {
        this.graph = graph;
        this.render();
      }

      render() {
        if (!this.graph) return;

        const ctx = this.ctx;
        const rect = this.canvas.getBoundingClientRect();
        
        // Clear canvas
        ctx.clearRect(0, 0, rect.width, rect.height);
        
        // Draw edges
        this.drawEdges();
        
        // Draw nodes
        this.drawNodes();
        
        // Draw labels
        this.drawLabels();
      }

      drawEdges() {
        const ctx = this.ctx;
        const { positions, adjacency } = this.graph;
        
        ctx.strokeStyle = this.edgeColor;
        ctx.lineWidth = this.edgeWidth;
        
        for (let i = 0; i < positions.length; i++) {
          for (let j = i + 1; j < positions.length; j++) {
            if (adjacency[i][j]) {
              ctx.beginPath();
              ctx.moveTo(positions[i].x, positions[i].y);
              ctx.lineTo(positions[j].x, positions[j].y);
              ctx.stroke();
            }
          }
        }
      }

      drawNodes() {
        const ctx = this.ctx;
        const { positions } = this.graph;
        
        positions.forEach((pos, i) => {
          const isHovered = this.getNodeAtPosition(this.mousePos) === i;
          const isDragged = this.dragNode === i;
          
          // Node shadow
          ctx.beginPath();
          ctx.arc(pos.x + 2, pos.y + 2, this.nodeRadius, 0, 2 * Math.PI);
          ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
          ctx.fill();
          
          // Node body
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, this.nodeRadius, 0, 2 * Math.PI);
          ctx.fillStyle = (isHovered || isDragged) ? this.selectedColor : this.nodeColor;
          ctx.fill();
          
          // Node border
          ctx.strokeStyle = this.nodeStroke;
          ctx.lineWidth = 3;
          ctx.stroke();
        });
      }

      drawLabels() {
        const ctx = this.ctx;
        const { positions } = this.graph;
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 10px Inter';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        positions.forEach((pos, i) => {
          ctx.fillText(i.toString(), pos.x, pos.y);
        });
      }

      updateProperties(properties) {
        document.getElementById('spectral-gap').textContent = 
          properties.spectralGap.toFixed(3);
        document.getElementById('algebraic-connectivity').textContent = 
          properties.algebraicConnectivity.toFixed(3);
      }
    }

    // eigenvalue-controls.js - Interactive UI components
    class EigenvalueControls {
      constructor(container, onChange) {
        this.container = container;
        this.onChange = onChange;
        this.nodeCount = 5;
        this.eigenvalues = [0, 0.5, 1.0, 1.5, 2.0];
        this.setupControls();
      }

      setupControls() {
        this.renderSliders();
        this.setupPresets();
        this.setupNodeCountControl();
      }

      renderSliders() {
        this.container.innerHTML = '';
        
        this.eigenvalues.forEach((value, index) => {
          const controlDiv = document.createElement('div');
          controlDiv.className = 'eigenvalue-control';
          
          controlDiv.innerHTML = `
            <div class="eigenvalue-label">
              <span>λ${index + 1}</span>
              <span class="eigenvalue-value">${value.toFixed(3)}</span>
            </div>
            <input type="range" 
                   class="eigenvalue-slider" 
                   id="eigenvalue-${index}"
                   min="0" 
                   max="5" 
                   step="0.01" 
                   value="${value}"
                   ${index === 0 ? 'disabled' : ''}>
          `;
          
          this.container.appendChild(controlDiv);
          
          const slider = controlDiv.querySelector('.eigenvalue-slider');
          const valueSpan = controlDiv.querySelector('.eigenvalue-value');
          
          slider.addEventListener('input', (e) => {
            const newValue = parseFloat(e.target.value);
            this.eigenvalues[index] = newValue;
            valueSpan.textContent = newValue.toFixed(3);
            this.onChange(this.eigenvalues);
          });
        });
      }

      setupPresets() {
        const presetButtons = document.querySelectorAll('.preset-btn');
        presetButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const preset = btn.dataset.preset;
            const engine = new GraphLaplacianEngine();
            this.eigenvalues = engine.getPresetEigenvalues(preset, this.nodeCount);
            this.updateSliders();
            this.onChange(this.eigenvalues);
          });
        });
      }

      setupNodeCountControl() {
        const nodeCountSelect = document.getElementById('node-count');
        nodeCountSelect.addEventListener('change', (e) => {
          this.nodeCount = parseInt(e.target.value);
          this.eigenvalues = new Array(this.nodeCount).fill(0).map((_, i) => i * 0.5);
          this.renderSliders();
          this.onChange(this.eigenvalues);
        });
      }

      updateSliders() {
        this.eigenvalues.forEach((value, index) => {
          const slider = document.getElementById(`eigenvalue-${index}`);
          const valueSpan = slider.parentElement.querySelector('.eigenvalue-value');
          if (slider) {
            slider.value = value;
            valueSpan.textContent = value.toFixed(3);
          }
        });
      }

      setEigenvalues(eigenvalues) {
        this.eigenvalues = [...eigenvalues];
        this.updateSliders();
      }
    }

    // main-applet.js - Orchestration and state management
    class GraphLaplacianApplet {
      constructor() {
        this.engine = new GraphLaplacianEngine();
        this.visualizer = null;
        this.controls = null;
        this.eigenvalueChart = null;
        this.eigenvectorVisualizer = null;
        this.currentGraph = null;
        this.worker = null;
        
        this.init();
      }

      async init() {
        // Setup visualizer
        const canvas = document.getElementById('graph-canvas');
        this.visualizer = new GraphVisualizer(canvas);
        
        // Setup eigenvalue chart
        const chartCanvas = document.getElementById('eigenvalue-chart');
        this.eigenvalueChart = new EigenvalueChart(chartCanvas);
        
        // Setup eigenvector visualizer
        this.eigenvectorVisualizer = new EigenvectorVisualizer(this.visualizer);
        
        // Setup intuitive property controls
        this.controls = new PropertyControls(
          document, // Pass document as the controls span multiple containers
          (eigenvalues) => this.onEigenvaluesChanged(eigenvalues)
        );
        
        // Setup tabs
        this.setupTabs();
        
        // Setup eigenvector controls
        this.setupEigenvectorControls();
        
        // Setup worker for heavy computations
        this.setupWorker();
        
        // Initial graph - start with a simple path to demonstrate
        this.generateInitialGraph();
        
        // Handle window resize
        window.addEventListener('resize', () => {
          this.visualizer.setupCanvas();
          this.eigenvalueChart.setupCanvas();
          this.visualizer.render();
          this.eigenvalueChart.render();
        });
      }

      setupTabs() {
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabPanels = document.querySelectorAll('.tab-panel');
        
        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            const targetTab = button.dataset.tab;
            
            // Update button states
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            
            // Update panel visibility
            tabPanels.forEach(panel => panel.classList.remove('active'));
            const targetPanel = document.getElementById(`${targetTab}-panel`);
            if (targetPanel) {
              targetPanel.classList.add('active');
            }
            
            // Clear eigenvector colors when switching away from eigenvectors tab
            if (targetTab !== 'eigenvectors') {
              this.visualizer.clearEigenvectorColors();
            } else {
              // Update eigenvector visualization when switching to it
              this.eigenvectorVisualizer.updateVisualization();
            }
          });
        });
      }

      setupEigenvectorControls() {
        const eigenvectorSelect = document.getElementById('eigenvector-select');
        const animateButton = document.getElementById('animate-pattern');
        
        eigenvectorSelect.addEventListener('change', (e) => {
          const selectedIndex = parseInt(e.target.value);
          this.eigenvectorVisualizer.setSelectedVector(selectedIndex);
        });
        
        animateButton.addEventListener('click', () => {
          this.eigenvectorVisualizer.animatePattern();
        });
      }

      setupWorker() {
        // For this demo, we'll compute synchronously
        // In production, use Web Workers for heavy computations
        this.worker = {
          postMessage: (data) => {
            setTimeout(() => {
              const result = this.engine.generateGraphFromEigenvalues(data.eigenvalues);
              this.onWorkerMessage({ data: result });
            }, 50);
          }
        };
      }

      onWorkerMessage(event) {
        const graph = event.data;
        this.currentGraph = graph;
        
        // Update main graph visualization
        this.visualizer.setGraph(graph);
        this.visualizer.updateProperties(graph.properties);
        
        // Update eigenvalue chart
        this.eigenvalueChart.updateEigenvalues(graph.eigenvalues);
        
        // Update eigenvector visualization
        this.eigenvectorVisualizer.updateEigenvectors(graph.eigenvalues, graph);
        
        // Update insights
        this.updateEigenvalueInsights(graph.eigenvalues, graph.properties);
        
        // Update the explanation based on what we're showing
        this.updateDynamicExplanation(graph);
      }

      updateEigenvalueInsights(eigenvalues, properties) {
        // Update second eigenvalue meaning
        const secondEl = document.getElementById('second-eigenvalue-meaning');
        if (eigenvalues[1] > 2.0) {
          secondEl.textContent = "Strong connectivity - information flows quickly";
        } else if (eigenvalues[1] > 1.0) {
          secondEl.textContent = "Good connectivity - well-connected network";
        } else if (eigenvalues[1] > 0.3) {
          secondEl.textContent = "Moderate connectivity - some bottlenecks";
        } else {
          secondEl.textContent = "Weak connectivity - fragmented network";
        }
        
        // Update largest eigenvalue meaning
        const largestEl = document.getElementById('largest-eigenvalue-meaning');
        const largest = eigenvalues[eigenvalues.length - 1];
        const n = eigenvalues.length;
        
        if (largest > n) {
          largestEl.textContent = "High maximum degree - hub-like structure";
        } else if (largest > n * 0.7) {
          largestEl.textContent = "Moderate hubs present";
        } else {
          largestEl.textContent = "Uniform degree distribution";
        }
      }

      updateDynamicExplanation(graph) {
        const explanationEl = document.getElementById('explanation-text');
        const properties = this.controls.getProperties();
        const { spectralGap, algebraicConnectivity } = graph.properties;
        
        let explanation = `Your ${this.getGraphDescription(graph)} has `;
        
        if (algebraicConnectivity > 2.0) {
          explanation += "excellent connectivity - information flows quickly between all nodes. ";
        } else if (algebraicConnectivity > 1.0) {
          explanation += "good connectivity - most nodes can communicate efficiently. ";
        } else if (algebraicConnectivity > 0.3) {
          explanation += "moderate connectivity - some bottlenecks may exist. ";
        } else {
          explanation += "limited connectivity - the graph may have weak points. ";
        }
        
        explanation += `The network health score of ${spectralGap.toFixed(2)} indicates ${
          spectralGap > 1.0 ? "rapid information propagation and strong structural integrity" : 
          "slower information flow and potential structural weaknesses"
        }.`;
        
        explanationEl.innerHTML = explanation;
      }

      getGraphDescription(graph) {
        const validation = this.engine.validateEigenvalues(graph.eigenvalues);
        if (validation.valid && validation.graphType && validation.confidence > 0.9) {
          const typeNames = {
            path: "chain of connected nodes",
            cycle: "circular ring network", 
            complete: "fully connected network",
            star: "hub-and-spoke network"
          };
          return typeNames[validation.graphType] || "network";
        }
        return "network";
      }

      generateInitialGraph() {
        // Start with moderate connectivity that matches the HTML defaults
        // Don't call setProperties since the PropertyControls already initializes correctly
        // Just trigger the first graph generation
        setTimeout(() => {
          const currentProps = this.controls.getProperties();
          const eigenvalues = this.controls.solver.solveForProperties(currentProps, this.controls.nodeCount);
          this.onEigenvaluesChanged(eigenvalues);
        }, 100);
      }

      onEigenvaluesChanged(eigenvalues) {
        // Generate graph (via worker in production)
        this.worker.postMessage({ eigenvalues });
      }
    }

    // Initialize the applet when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      // Add canvas round rect polyfill for older browsers
      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
          this.beginPath();
          this.moveTo(x + radius, y);
          this.lineTo(x + width - radius, y);
          this.quadraticCurveTo(x + width, y, x + width, y + radius);
          this.lineTo(x + width, y + height - radius);
          this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
          this.lineTo(x + radius, y + height);
          this.quadraticCurveTo(x, y + height, x, y + height - radius);
          this.lineTo(x, y + radius);
          this.quadraticCurveTo(x, y, x + radius, y);
          this.closePath();
        };
      }
      
      const applet = new GraphLaplacianApplet();
      window.graphLaplacianApplet = applet; // For debugging
    });
  </script>
</body>
</html>