<!-- graph-laplacian.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Interactive visualization of graph Laplacian eigenvalues and their effect on graph structure">
  <title>Graph Laplacian Eigenvalue Visualizer ‚Äî Jack Kinney</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <style>
    /* CSS Variables matching your existing theme */
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --primary-light: #a5b4fc;
      --secondary: #ec4899;
      --accent: #f59e0b;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;

      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-tertiary: #e2e8f0;
      --bg-card: #ffffff;
      --bg-card-hover: #f1f5f9;

      --text-primary: #0f172a;
      --text-secondary: #475569;
      --text-muted: #64748b;

      --border: #e2e8f0;
      --border-light: #cbd5e1;

      --space-1: 0.25rem;
      --space-2: 0.5rem;
      --space-3: 0.75rem;
      --space-4: 1rem;
      --space-6: 1.5rem;
      --space-8: 2rem;
      --space-12: 3rem;
      --space-16: 4rem;

      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --font-mono: 'JetBrains Mono', 'SF Mono', 'Monaco', 'Consolas', monospace;

      --radius: 0.5rem;
      --radius-lg: 1rem;
      --radius-xl: 1.5rem;

      --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
      --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1);

      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-sans);
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      min-height: 100vh;
    }

    .container {
      width: 100%;
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 var(--space-6);
    }

    /* Header */
    .header {
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border);
      padding: var(--space-4) 0;
      position: sticky;
      top: 0;
      z-index: 100;
      backdrop-filter: blur(20px);
    }

    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--text-primary);
      font-family: var(--font-mono);
      text-decoration: none;
    }

    .back-link {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      color: var(--primary);
      text-decoration: none;
      font-weight: 500;
      transition: var(--transition);
    }

    .back-link:hover {
      color: var(--primary-dark);
    }

    /* Main Layout */
    .main-content {
      padding: var(--space-8) 0;
    }

    .app-header {
      text-align: center;
      margin-bottom: var(--space-12);
    }

    .app-title {
      font-size: 2.5rem;
      font-weight: 800;
      margin-bottom: var(--space-4);
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .app-description {
      font-size: 1.125rem;
      color: var(--text-secondary);
      max-width: 800px;
      margin: 0 auto;
    }

    /* App Layout */
    .app-container {
      display: grid;
      grid-template-columns: 350px 1fr;
      gap: var(--space-8);
      min-height: 600px;
    }

    .controls-panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      padding: var(--space-6);
      height: fit-content;
      position: sticky;
      top: 120px;
      box-shadow: var(--shadow-lg);
    }

    .visualization-panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      padding: var(--space-6);
      box-shadow: var(--shadow-lg);
    }

    /* Controls */
    .control-section {
      margin-bottom: var(--space-6);
    }

    .control-section:last-child {
      margin-bottom: 0;
    }

    .section-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: var(--space-4);
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .eigenvalue-control.snapped {
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid var(--success);
      border-radius: var(--radius);
      transform: scale(1.02);
      transition: all 0.3s ease;
    }

    .snap-tooltip {
      position: absolute;
      top: -35px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--success);
      color: white;
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius);
      font-size: 0.75rem;
      white-space: nowrap;
      z-index: 1000;
      animation: fadeInOut 1s ease;
    }

    .snap-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 4px solid transparent;
      border-top-color: var(--success);
    }

    @keyframes fadeInOut {
      0%, 100% { opacity: 0; transform: translateX(-50%) translateY(-5px); }
      20%, 80% { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Property Controls */
    .property-control {
      margin-bottom: var(--space-6);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-4);
      transition: var(--transition);
    }

    .property-control:hover {
      border-color: var(--primary);
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.1);
    }

    .property-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--space-3);
      font-weight: 600;
      color: var(--text-primary);
    }

    .property-label i {
      color: var(--text-muted);
      cursor: help;
    }

    .property-slider-container {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      margin-bottom: var(--space-2);
    }

    .property-slider {
      flex: 1;
      height: 8px;
      border-radius: 4px;
      background: var(--bg-tertiary);
      outline: none;
      transition: var(--transition);
      -webkit-appearance: none;
    }

    .property-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      transition: var(--transition);
    }

    .property-slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
    }

    .property-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    .slider-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      white-space: nowrap;
      font-weight: 500;
    }

    .property-value {
      text-align: center;
      font-size: 0.875rem;
      color: var(--primary);
      font-weight: 500;
      background: rgba(99, 102, 241, 0.1);
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius);
    }

    .help-text {
      font-size: 0.875rem;
      color: var(--text-muted);
      margin-bottom: var(--space-4);
      line-height: 1.5;
      font-style: italic;
    }

    .setting-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-3);
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .setting-label select {
      padding: var(--space-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: inherit;
    }

    .advanced-toggle {
      margin-top: var(--space-4);
    }

    .advanced-toggle label {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      font-size: 0.875rem;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .advanced-toggle input[type="checkbox"] {
      transform: scale(1.2);
      accent-color: var(--primary);
    }

    .advanced-section {
      border-top: 1px solid var(--border);
      padding-top: var(--space-6);
      margin-top: var(--space-6);
    }

    .explanation {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(236, 72, 153, 0.1));
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: var(--radius);
      padding: var(--space-4);
      font-size: 0.875rem;
      line-height: 1.6;
      color: var(--text-secondary);
      position: relative;
      overflow: hidden;
    }

    .explanation::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: linear-gradient(180deg, var(--primary), var(--secondary));
    }

    #eigenvalue-display {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
      font-family: var(--font-mono);
      font-size: 0.8rem;
      max-height: 150px;
      overflow-y: auto;
    }

    .eigenvalue-item {
      display: flex;
      justify-content: space-between;
      padding: var(--space-1) 0;
      border-bottom: 1px solid var(--border);
    }

    .eigenvalue-item:last-child {
      border-bottom: none;
    }

    .eigenvalue-item .label {
      color: var(--text-muted);
    }

    .eigenvalue-item .value {
      color: var(--primary);
      font-weight: 500;
    }

    /* Analysis Tabs */
    .analysis-tabs {
      display: flex;
      gap: var(--space-1);
      margin: var(--space-6) 0 var(--space-4) 0;
      border-bottom: 2px solid var(--border);
    }

    .tab-btn {
      padding: var(--space-3) var(--space-4);
      background: none;
      border: none;
      border-bottom: 3px solid transparent;
      color: var(--text-muted);
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
      font-family: inherit;
      font-size: 0.875rem;
    }

    .tab-btn:hover {
      color: var(--text-primary);
      background: var(--bg-secondary);
    }

    .tab-btn.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
      background: var(--bg-secondary);
    }

    .tab-content {
      min-height: 300px;
    }

    .tab-panel {
      display: none;
      animation: fadeIn 0.3s ease;
    }

    .tab-panel.active {
      display: block;
    }

    .panel-header {
      margin-bottom: var(--space-4);
    }

    .panel-header h4 {
      margin-bottom: var(--space-2);
      color: var(--text-primary);
    }

    .panel-header p {
      color: var(--text-muted);
      font-size: 0.875rem;
    }

    /* Eigenvalue Chart */
    .eigenvalue-chart {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-4);
      margin-bottom: var(--space-4);
      display: flex;
      justify-content: center;
    }

    .eigenvalue-insights {
      display: grid;
      gap: var(--space-2);
    }

    .insight-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-2) var(--space-3);
      background: var(--bg-secondary);
      border-radius: var(--radius);
      font-size: 0.875rem;
    }

    .insight-label {
      color: var(--text-secondary);
      font-weight: 500;
    }

    .insight-value {
      color: var(--primary);
      font-weight: 600;
    }

    /* Eigenvector Controls */
    .eigenvector-controls {
      display: flex;
      align-items: center;
      gap: var(--space-4);
      margin-bottom: var(--space-4);
      padding: var(--space-3);
      background: var(--bg-secondary);
      border-radius: var(--radius);
    }

    .eigenvector-controls label {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      font-size: 0.875rem;
    }

    .eigenvector-controls select {
      padding: var(--space-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    .animation-btn {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-3);
      background: var(--primary);
      color: white;
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 0.875rem;
      transition: var(--transition);
    }

    .animation-btn:hover {
      background: var(--primary-dark);
      transform: translateY(-1px);
    }

    .eigenvector-explanation {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(16, 185, 129, 0.1));
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: var(--radius);
      padding: var(--space-4);
      font-size: 0.875rem;
      line-height: 1.6;
      color: var(--text-secondary);
    }

    /* Learning Section */
    .learning-section {
      max-height: 400px;
      overflow-y: auto;
      padding-right: var(--space-2);
    }

    .learning-section h4 {
      margin-bottom: var(--space-4);
      color: var(--text-primary);
      text-align: center;
      font-size: 1.25rem;
    }

    .concept-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--space-4);
      margin-bottom: var(--space-4);
      transition: var(--transition);
    }

    .concept-card:hover {
      border-color: var(--primary);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.1);
    }

    .concept-card.highlight {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(236, 72, 153, 0.1));
      border-color: var(--primary);
    }

    .concept-header {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      margin-bottom: var(--space-3);
    }

    .concept-header i {
      font-size: 1.25rem;
      color: var(--primary);
      width: 24px;
      text-align: center;
    }

    .concept-header h5 {
      margin: 0;
      color: var(--text-primary);
      font-size: 1rem;
    }

    .concept-card p {
      margin-bottom: var(--space-3);
      line-height: 1.6;
    }

    .concept-card ul {
      margin: 0;
      padding-left: var(--space-4);
    }

    .concept-card li {
      margin-bottom: var(--space-2);
      line-height: 1.5;
    }

    .concept-card li strong {
      color: var(--primary);
    }

    /* Custom scrollbar for learning section */
    .learning-section::-webkit-scrollbar {
      width: 6px;
    }

    .learning-section::-webkit-scrollbar-track {
      background: var(--bg-tertiary);
      border-radius: 3px;
    }

    .learning-section::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 3px;
    }

    /* Textbook Layout */
    .textbook-container {
      max-height: 500px;
      overflow-y: auto;
      background: var(--bg-primary);
      border-radius: var(--radius-lg);
      padding: var(--space-6);
    }

    .textbook-header {
      text-align: center;
      margin-bottom: var(--space-6);
      padding-bottom: var(--space-4);
      border-bottom: 2px solid var(--border);
    }

    .textbook-header h3 {
      color: var(--primary);
      margin-bottom: var(--space-2);
      font-size: 1.5rem;
    }

    .textbook-subtitle {
      color: var(--text-muted);
      font-style: italic;
      line-height: 1.6;
    }

    .textbook-nav {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      margin-bottom: var(--space-6);
      padding-bottom: var(--space-4);
      border-bottom: 1px solid var(--border);
    }

    .chapter-btn {
      padding: var(--space-2) var(--space-3);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      color: var(--text-secondary);
      font-size: 0.8rem;
      cursor: pointer;
      transition: var(--transition);
      font-family: inherit;
    }

    .chapter-btn:hover {
      color: var(--primary);
      border-color: var(--primary);
    }

    .chapter-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .textbook-content {
      min-height: 400px;
    }

    .chapter {
      display: none;
      animation: fadeIn 0.3s ease;
    }

    .chapter.active {
      display: block;
    }

    .chapter h4 {
      color: var(--primary);
      margin-bottom: var(--space-4);
      font-size: 1.25rem;
    }

    .chapter-number {
      background: var(--primary);
      color: white;
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius);
      font-size: 0.875rem;
      margin-right: var(--space-2);
    }

    .section {
      margin-bottom: var(--space-6);
    }

    .section h5 {
      color: var(--text-primary);
      margin-bottom: var(--space-3);
      font-size: 1.1rem;
    }

    .section h6 {
      color: var(--primary);
      margin-bottom: var(--space-2);
      font-size: 1rem;
    }

    .application-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-3);
      margin: var(--space-4) 0;
    }

    .application-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
      text-align: center;
      transition: var(--transition);
    }

    .application-card:hover {
      border-color: var(--primary);
      transform: translateY(-2px);
    }

    .application-card i {
      font-size: 1.5rem;
      color: var(--primary);
      margin-bottom: var(--space-2);
    }

    .application-card h6 {
      margin-bottom: var(--space-2);
      font-size: 0.9rem;
    }

    .application-card p {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .interactive-demo {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(16, 185, 129, 0.1));
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: var(--radius);
      padding: var(--space-4);
      margin: var(--space-4) 0;
    }

    .interactive-demo h6 {
      color: var(--primary);
      margin-bottom: var(--space-2);
    }

    .matrix-explanation {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-4);
      margin: var(--space-4) 0;
    }

    .matrix-type {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
      text-align: center;
    }

    .matrix-type.highlight {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
    }

    .matrix-visual {
      margin-top: var(--space-3);
    }

    .matrix-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2px;
      width: fit-content;
      margin: 0 auto var(--space-2);
    }

    .matrix-cell {
      width: 30px;
      height: 30px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .matrix-caption {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .eigenvalue-meanings {
      display: grid;
      gap: var(--space-4);
      margin: var(--space-4) 0;
    }

    .eigenvalue-meaning {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-4);
    }

    .eigenvalue-meaning.highlight {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
    }

    .insight-box {
      background: rgba(16, 185, 129, 0.1);
      border-left: 4px solid var(--success);
      padding: var(--space-3);
      margin-top: var(--space-3);
      border-radius: 0 var(--radius) var(--radius) 0;
    }

    .spectral-gap-effects {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-3);
      margin: var(--space-4) 0;
    }

    .effect-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
      text-align: center;
    }

    .eigenvector-explanation {
      display: grid;
      gap: var(--space-4);
      margin: var(--space-4) 0;
    }

    .eigenvector-type {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-4);
    }

    .eigenvector-type.highlight {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
    }

    .interpretation {
      background: rgba(236, 72, 153, 0.1);
      border-left: 4px solid var(--secondary);
      padding: var(--space-3);
      margin-top: var(--space-3);
      border-radius: 0 var(--radius) var(--radius) 0;
    }

    .application-detailed {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-4);
      margin-bottom: var(--space-4);
    }

    .algorithm-steps {
      display: grid;
      gap: var(--space-2);
      margin-top: var(--space-3);
    }

    .step {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-2) var(--space-3);
      position: relative;
      padding-left: var(--space-8);
    }

    .step::before {
      content: counter(step);
      counter-increment: step;
      position: absolute;
      left: var(--space-2);
      width: 20px;
      height: 20px;
      background: var(--primary);
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      font-weight: bold;
    }

    .algorithm-steps {
      counter-reset: step;
    }

    .clustering-steps {
      display: grid;
      gap: var(--space-3);
      margin-top: var(--space-3);
    }

    .clustering-step {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
    }

    .emerging-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-3);
      margin-top: var(--space-3);
    }

    .emerging-app {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
    }

    .laplacian-variants {
      display: grid;
      gap: var(--space-3);
      margin: var(--space-4) 0;
    }

    .variant {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
    }

    .research-questions {
      display: grid;
      gap: var(--space-3);
      margin: var(--space-4) 0;
    }

    .question {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
    }

    .resources {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: var(--space-4);
      margin-top: var(--space-3);
    }

    .resource-category {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .eigenvalue-label {
      display: flex;
      justify-content: between;
      align-items: center;
      margin-bottom: var(--space-2);
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .eigenvalue-slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--bg-tertiary);
      outline: none;
      transition: var(--transition);
      -webkit-appearance: none;
    }

    .eigenvalue-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: var(--shadow);
    }

    .eigenvalue-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: var(--shadow);
    }

    .preset-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-3);
    }

    .preset-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    .preset-btn {
      padding: var(--space-2) var(--space-3);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      color: var(--text-primary);
      font-size: 0.875rem;
      cursor: pointer;
      transition: var(--transition);
      font-family: inherit;
      position: relative;
      overflow: hidden;
    }

    .preset-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s ease;
    }

    .preset-btn:hover::before {
      left: 100%;
    }

    /* Remove old status display styles - replaced with integrated explanations */

    /* Canvas */
    .canvas-container {
      position: relative;
      width: 100%;
      height: 600px;
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      overflow: hidden;
      background: linear-gradient(45deg, #f8fafc 25%, transparent 25%), 
                  linear-gradient(-45deg, #f8fafc 25%, transparent 25%), 
                  linear-gradient(45deg, transparent 75%, #f8fafc 75%), 
                  linear-gradient(-45deg, transparent 75%, #f8fafc 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }

    #graph-canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #graph-canvas:active {
      cursor: grabbing;
    }

    .canvas-overlay {
      position: absolute;
      top: var(--space-4);
      right: var(--space-4);
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
      font-size: 0.875rem;
      backdrop-filter: blur(10px);
    }

    /* Info Panel */
    .info-panel {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--space-4);
      margin-top: var(--space-6);
    }

    .info-title {
      font-weight: 600;
      margin-bottom: var(--space-2);
      color: var(--text-primary);
    }

    .info-text {
      font-size: 0.875rem;
      color: var(--text-secondary);
      line-height: 1.6;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .app-container {
        grid-template-columns: 1fr;
        gap: var(--space-6);
      }

      .controls-panel {
        position: static;
        order: 2;
      }

      .preset-buttons {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 0 var(--space-4);
      }

      .app-title {
        font-size: 2rem;
      }

      .canvas-container {
        height: 400px;
      }

      .preset-buttons {
        grid-template-columns: 1fr 1fr;
      }
    }

    /* Loading Animation */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 200px;
      color: var(--text-muted);
      font-size: 0.875rem;
    }

    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-top: 2px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: var(--space-2);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="container">
      <div class="header-content">
        <a href="./index.html" class="logo">&lt;JTK/&gt;</a>
        <a href="./projects.html" class="back-link">
          <i class="fas fa-arrow-left"></i>
          Back to Projects
        </a>
      </div>
    </div>
  </header>

  <main class="main-content">
    <div class="container">
      <div class="app-header">
        <h1 class="app-title">Graph Laplacian Eigenvalue Visualizer</h1>
        <p class="app-description">
          Discover how graph connectivity, clustering, and spread affect network structure! 
          Adjust intuitive properties and watch as the mathematical eigenvalues automatically 
          update to create valid graph configurations. No spectral graph theory knowledge required.
        </p>
      </div>

      <div class="app-container">
        <div class="controls-panel">
          <div class="control-section">
            <h3 class="section-title">
              <i class="fas fa-network-wired"></i>
              Graph Properties
            </h3>
            <div class="help-text">
              Adjust how connected and clustered your graph is. The math happens automatically!
            </div>
            
            <div class="property-control">
              <div class="property-label">
                <span>How Connected?</span>
                <i class="fas fa-question-circle" title="Higher values create more tightly connected graphs"></i>
              </div>
              <div class="property-slider-container">
                <span class="slider-label">Sparse</span>
                <input type="range" class="property-slider" id="connectivity-slider" 
                       min="0" max="100" value="30" data-property="connectivity">
                <span class="slider-label">Dense</span>
              </div>
              <div class="property-value">Low connectivity</div>
            </div>

            <div class="property-control">
              <div class="property-label">
                <span>How Spread Out?</span>
                <i class="fas fa-question-circle" title="Controls how far apart different parts of the graph are"></i>
              </div>
              <div class="property-slider-container">
                <span class="slider-label">Tight</span>
                <input type="range" class="property-slider" id="expansion-slider" 
                       min="0" max="100" value="60" data-property="expansion">
                <span class="slider-label">Spread</span>
              </div>
              <div class="property-value">Balanced spread</div>
            </div>

            <div class="property-control">
              <div class="property-label">
                <span>How Clustered?</span>
                <i class="fas fa-question-circle" title="Higher values create more distinct groups or clusters"></i>
              </div>
              <div class="property-slider-container">
                <span class="slider-label">Uniform</span>
                <input type="range" class="property-slider" id="clustering-slider" 
                       min="0" max="100" value="15" data-property="clustering">
                <span class="slider-label">Clustered</span>
              </div>
              <div class="property-value">Very low clustering</div>
            </div>
          </div>

          <div class="control-section">
            <h3 class="section-title">
              <i class="fas fa-shapes"></i>
              Common Examples
            </h3>
            <div class="help-text">
              Try these classic graph types to see how properties change
            </div>
            <div class="preset-buttons">
              <button class="preset-btn" data-preset="path" title="Nodes in a line">
                <i class="fas fa-minus"></i> Chain
              </button>
              <button class="preset-btn" data-preset="cycle" title="Nodes in a circle">
                <i class="fas fa-circle-notch"></i> Ring
              </button>
              <button class="preset-btn" data-preset="star" title="One center, many spokes">
                <i class="fas fa-star"></i> Star
              </button>
              <button class="preset-btn" data-preset="complete" title="Everyone connected to everyone">
                <i class="fas fa-project-diagram"></i> Complete
              </button>
            </div>
          </div>

          <div class="control-section">
            <h3 class="section-title">
              <i class="fas fa-cog"></i>
              Settings
            </h3>
            <label class="setting-label">
              <span>Number of nodes:</span>
              <select id="node-count">
                <option value="4">4 nodes</option>
                <option value="5" selected>5 nodes</option>
                <option value="6">6 nodes</option>
                <option value="7">7 nodes</option>
                <option value="8">8 nodes</option>
              </select>
            </label>
            
            <div class="advanced-toggle">
              <label>
                <input type="checkbox" id="show-advanced"> 
                Show eigenvalue details
              </label>
            </div>
          </div>

          <div class="control-section advanced-section" style="display: none;">
            <h3 class="section-title">
              <i class="fas fa-calculator"></i>
              Mathematical Details
            </h3>
            <div class="help-text">
              The eigenvalues that make your graph possible (auto-calculated)
            </div>
            <div id="eigenvalue-display">
              <!-- Eigenvalues shown as read-only information -->
            </div>
          </div>

          <div class="control-section">
            <h3 class="section-title">
              <i class="fas fa-lightbulb"></i>
              What You're Seeing
            </h3>
            <div id="explanation-text" class="explanation">
              Drag the sliders above to see how different properties affect your graph's structure!
            </div>
          </div>
        </div>

        <div class="visualization-panel">
          <div class="canvas-container">
            <canvas id="graph-canvas"></canvas>
            <div class="canvas-overlay">
              <div><strong>Network Health:</strong> <span id="spectral-gap">0.00</span></div>
              <div><strong>Connection Strength:</strong> <span id="algebraic-connectivity">0.00</span></div>
              <div style="font-size: 0.75rem; margin-top: 0.5rem; opacity: 0.8;">
                Higher values = better connectivity
              </div>
            </div>
          </div>

          <div class="analysis-tabs">
            <button class="tab-btn active" data-tab="eigenvalues">Eigenvalue Spectrum</button>
            <button class="tab-btn" data-tab="eigenvectors">Vibration Patterns</button>
            <button class="tab-btn" data-tab="learn">Learn Spectral Theory</button>
          </div>

          <div class="tab-content">
            <!-- Eigenvalue Distribution Plot -->
            <div class="tab-panel active" id="eigenvalues-panel">
              <div class="panel-header">
                <h4>Eigenvalue Distribution</h4>
                <p>Each bar represents an eigenvalue - the mathematical "fingerprint" of your graph</p>
              </div>
              <div class="eigenvalue-chart">
                <canvas id="eigenvalue-chart" width="500" height="200"></canvas>
              </div>
              <div class="eigenvalue-insights">
                <div class="insight-item">
                  <span class="insight-label">First eigenvalue (Œª‚ÇÅ):</span>
                  <span class="insight-value">Always 0 for connected graphs</span>
                </div>
                <div class="insight-item">
                  <span class="insight-label">Second eigenvalue (Œª‚ÇÇ):</span>
                  <span class="insight-value" id="second-eigenvalue-meaning">Shows connectivity strength</span>
                </div>
                <div class="insight-item">
                  <span class="insight-label">Largest eigenvalue:</span>
                  <span class="insight-value" id="largest-eigenvalue-meaning">Related to maximum degree</span>
                </div>
              </div>
            </div>

            <!-- Eigenvector Visualization -->
            <div class="tab-panel" id="eigenvectors-panel">
              <div class="panel-header">
                <h4>Vibration Patterns (Eigenvectors)</h4>
                <p>Each pattern shows how energy or information flows through your network</p>
              </div>
              <div class="eigenvector-controls">
                <label>
                  <span>Pattern to show:</span>
                  <select id="eigenvector-select">
                    <option value="1">Pattern 2 (Connectivity)</option>
                    <option value="2">Pattern 3 (Clustering)</option>
                    <option value="3">Pattern 4 (Higher Order)</option>
                  </select>
                </label>
                <button id="animate-pattern" class="animation-btn">
                  <i class="fas fa-play"></i> Animate Flow
                </button>
              </div>
              <div class="eigenvector-explanation" id="eigenvector-explanation">
                Select a pattern above to see how it divides and connects your network
              </div>
            </div>

            <!-- Educational Content - Interactive Textbook -->
            <div class="tab-panel" id="learn-panel">
              <div class="textbook-container">
                <div class="textbook-header">
                  <h3>Spectral Graph Theory: An Interactive Guide</h3>
                  <p class="textbook-subtitle">
                    From basic concepts to advanced applications - learn the mathematics that powers 
                    modern network analysis, machine learning, and quantum computing.
                  </p>
                </div>

                <div class="textbook-nav">
                  <button class="chapter-btn active" data-chapter="motivation">1. Why Spectral Theory?</button>
                  <button class="chapter-btn" data-chapter="foundations">2. Mathematical Foundations</button>
                  <button class="chapter-btn" data-chapter="eigenvalues">3. Understanding Eigenvalues</button>
                  <button class="chapter-btn" data-chapter="eigenvectors">4. Eigenvectors & Flow</button>
                  <button class="chapter-btn" data-chapter="applications">5. Real-World Applications</button>
                  <button class="chapter-btn" data-chapter="advanced">6. Advanced Topics</button>
                </div>

                <div class="textbook-content">
                  <!-- Chapter 1: Motivation -->
                  <div class="chapter active" id="motivation-chapter">
                    <h4><span class="chapter-number">Chapter 1:</span> Why Spectral Graph Theory?</h4>
                    
                    <div class="section">
                      <h5>The Network Revolution</h5>
                      <p>
                        We live in an interconnected world. Social networks connect billions of people. 
                        Neural networks in our brains have trillions of connections. The internet links 
                        every computer on Earth. Understanding these networks is crucial for:
                      </p>
                      
                      <div class="application-grid">
                        <div class="application-card">
                          <i class="fas fa-search"></i>
                          <h6>Search Engines</h6>
                          <p>Google's PageRank uses the dominant eigenvector to rank web pages</p>
                        </div>
                        <div class="application-card">
                          <i class="fas fa-users"></i>
                          <h6>Social Networks</h6>
                          <p>Finding communities and predicting connections in social media</p>
                        </div>
                        <div class="application-card">
                          <i class="fas fa-brain"></i>
                          <h6>Neuroscience</h6>
                          <p>Understanding brain connectivity and information processing</p>
                        </div>
                        <div class="application-card">
                          <i class="fas fa-robot"></i>
                          <h6>Machine Learning</h6>
                          <p>Spectral clustering and dimensionality reduction algorithms</p>
                        </div>
                      </div>
                    </div>

                    <div class="section">
                      <h5>The Limitation of Traditional Graph Theory</h5>
                      <p>
                        Traditional graph theory focuses on <strong>local properties</strong>:
                      </p>
                      <ul>
                        <li>Degree of individual nodes</li>
                        <li>Shortest paths between specific pairs</li>
                        <li>Local clustering coefficients</li>
                      </ul>
                      
                      <p>
                        But networks have <strong>global emergent properties</strong> that can't be understood 
                        by looking at individual parts. This is where spectral theory shines.
                      </p>
                    </div>

                    <div class="interactive-demo">
                      <h6>üéµ The Music Analogy</h6>
                      <p>
                        Think of your graph as a musical instrument. When you pluck a guitar string, 
                        it doesn't vibrate at just any frequency - it has natural resonant frequencies 
                        determined by its physical properties.
                      </p>
                      <p>
                        Similarly, every graph has natural "frequencies" (eigenvalues) and "vibration patterns" 
                        (eigenvectors) that reveal its fundamental structure.
                      </p>
                    </div>
                  </div>

                  <!-- Chapter 2: Foundations -->
                  <div class="chapter" id="foundations-chapter">
                    <h4><span class="chapter-number">Chapter 2:</span> Mathematical Foundations</h4>
                    
                    <div class="section">
                      <h5>From Graphs to Matrices</h5>
                      <p>
                        The key insight of spectral graph theory is representing graphs as matrices, 
                        unlocking the full power of linear algebra.
                      </p>
                      
                      <div class="matrix-explanation">
                        <div class="matrix-type">
                          <h6>Adjacency Matrix (A)</h6>
                          <p>A[i,j] = 1 if nodes i and j are connected, 0 otherwise</p>
                          <div class="matrix-visual">
                            <div class="matrix-grid">
                              <div class="matrix-cell">0</div><div class="matrix-cell">1</div><div class="matrix-cell">0</div>
                              <div class="matrix-cell">1</div><div class="matrix-cell">0</div><div class="matrix-cell">1</div>
                              <div class="matrix-cell">0</div><div class="matrix-cell">1</div><div class="matrix-cell">0</div>
                            </div>
                            <span class="matrix-caption">3-node path graph</span>
                          </div>
                        </div>
                        
                        <div class="matrix-type">
                          <h6>Degree Matrix (D)</h6>
                          <p>D[i,i] = degree of node i, all other entries are 0</p>
                          <div class="matrix-visual">
                            <div class="matrix-grid">
                              <div class="matrix-cell">1</div><div class="matrix-cell">0</div><div class="matrix-cell">0</div>
                              <div class="matrix-cell">0</div><div class="matrix-cell">2</div><div class="matrix-cell">0</div>
                              <div class="matrix-cell">0</div><div class="matrix-cell">0</div><div class="matrix-cell">1</div>
                            </div>
                            <span class="matrix-caption">Diagonal degree matrix</span>
                          </div>
                        </div>
                        
                        <div class="matrix-type highlight">
                          <h6>Laplacian Matrix (L = D - A)</h6>
                          <p>The star of spectral graph theory - encodes both connectivity and structure</p>
                          <div class="matrix-visual">
                            <div class="matrix-grid">
                              <div class="matrix-cell">1</div><div class="matrix-cell">-1</div><div class="matrix-cell">0</div>
                              <div class="matrix-cell">-1</div><div class="matrix-cell">2</div><div class="matrix-cell">-1</div>
                              <div class="matrix-cell">0</div><div class="matrix-cell">-1</div><div class="matrix-cell">1</div>
                            </div>
                            <span class="matrix-caption">Laplacian = D - A</span>
                          </div>
                        </div>
                      </div>
                    </div>

                    <div class="section">
                      <h5>Why the Laplacian?</h5>
                      <p>
                        The Laplacian matrix L = D - A has remarkable properties:
                      </p>
                      <ul>
                        <li><strong>Symmetric:</strong> Has real eigenvalues and orthogonal eigenvectors</li>
                        <li><strong>Positive semidefinite:</strong> All eigenvalues ‚â• 0</li>
                        <li><strong>Encodes connectivity:</strong> Number of zero eigenvalues = number of connected components</li>
                        <li><strong>Discrete Laplace operator:</strong> Measures "smoothness" across the graph</li>
                      </ul>
                    </div>
                  </div>

                  <!-- Chapter 3: Eigenvalues -->
                  <div class="chapter" id="eigenvalues-chapter">
                    <h4><span class="chapter-number">Chapter 3:</span> Understanding Eigenvalues</h4>
                    
                    <div class="section">
                      <h5>The Eigenvalue Spectrum</h5>
                      <p>
                        For a graph with n nodes, the Laplacian has n eigenvalues: 0 = Œª‚ÇÅ ‚â§ Œª‚ÇÇ ‚â§ ... ‚â§ Œª‚Çô
                      </p>
                      
                      <div class="eigenvalue-meanings">
                        <div class="eigenvalue-meaning">
                          <h6>Œª‚ÇÅ = 0 (Always)</h6>
                          <p>
                            The smallest eigenvalue is always 0 for connected graphs. The multiplicity 
                            of this eigenvalue equals the number of connected components.
                          </p>
                          <div class="insight-box">
                            <strong>Insight:</strong> If your graph has Œª‚ÇÅ = Œª‚ÇÇ = 0, it has at least 2 disconnected parts!
                          </div>
                        </div>
                        
                        <div class="eigenvalue-meaning highlight">
                          <h6>Œª‚ÇÇ - Algebraic Connectivity</h6>
                          <p>
                            The second smallest eigenvalue is the most important. It measures how "well-connected" 
                            your graph is overall.
                          </p>
                          <ul>
                            <li>Œª‚ÇÇ = 0: Graph is disconnected</li>
                            <li>Small Œª‚ÇÇ: Graph has bottlenecks, poor connectivity</li>
                            <li>Large Œª‚ÇÇ: Graph is well-connected, information flows easily</li>
                          </ul>
                          <div class="insight-box">
                            <strong>Cheeger's Inequality:</strong> Œª‚ÇÇ bounds the conductance of the graph, 
                            relating spectral properties to combinatorial ones.
                          </div>
                        </div>
                        
                        <div class="eigenvalue-meaning">
                          <h6>Œª‚Çô - Maximum Eigenvalue</h6>
                          <p>
                            The largest eigenvalue relates to the maximum degree and overall "regularity" of the graph.
                          </p>
                          <ul>
                            <li>For regular graphs: Œª‚Çô ‚â§ maximum degree</li>
                            <li>Large Œª‚Çô: Graph has high-degree "hub" nodes</li>
                            <li>Œª‚Çô ‚âà average degree: Graph is roughly regular</li>
                          </ul>
                        </div>
                      </div>
                    </div>

                    <div class="section">
                      <h5>Spectral Gap</h5>
                      <p>
                        The gap Œª‚ÇÇ - Œª‚ÇÅ = Œª‚ÇÇ (since Œª‚ÇÅ = 0) is called the <strong>spectral gap</strong>. 
                        It's arguably the most important single number characterizing your graph:
                      </p>
                      
                      <div class="spectral-gap-effects">
                        <div class="effect-card">
                          <h6>Random Walks</h6>
                          <p>Larger gap ‚Üí faster mixing time ‚Üí random walks converge quickly to steady state</p>
                        </div>
                        <div class="effect-card">
                          <h6>Expansion</h6>
                          <p>Larger gap ‚Üí better expansion ‚Üí hard to find small cuts that disconnect the graph</p>
                        </div>
                        <div class="effect-card">
                          <h6>Connectivity</h6>
                          <p>Larger gap ‚Üí more robust connectivity ‚Üí graph survives random edge/node failures</p>
                        </div>
                      </div>
                    </div>
                  </div>

                  <!-- Chapter 4: Eigenvectors -->
                  <div class="chapter" id="eigenvectors-chapter">
                    <h4><span class="chapter-number">Chapter 4:</span> Eigenvectors & Information Flow</h4>
                    
                    <div class="section">
                      <h5>Eigenvectors as Vibration Patterns</h5>
                      <p>
                        If eigenvalues are the "frequencies," then eigenvectors are the "vibration patterns" 
                        that show how information, energy, or influence flows through your network.
                      </p>
                      
                      <div class="eigenvector-explanation">
                        <div class="eigenvector-type">
                          <h6>First Eigenvector (v‚ÇÅ)</h6>
                          <p>
                            Corresponds to Œª‚ÇÅ = 0. For connected graphs, this is the constant vector: 
                            v‚ÇÅ = (1, 1, 1, ..., 1). All nodes have the same value.
                          </p>
                          <div class="interpretation">
                            <strong>Interpretation:</strong> The "DC component" - uniform distribution across all nodes.
                          </div>
                        </div>
                        
                        <div class="eigenvector-type highlight">
                          <h6>Second Eigenvector (v‚ÇÇ) - Fiedler Vector</h6>
                          <p>
                            The most important eigenvector! It naturally partitions your graph into communities.
                          </p>
                          <ul>
                            <li><strong>Positive values:</strong> Nodes in one community</li>
                            <li><strong>Negative values:</strong> Nodes in another community</li>
                            <li><strong>Zero crossings:</strong> Natural boundaries between communities</li>
                          </ul>
                          <div class="interpretation">
                            <strong>Application:</strong> This is the foundation of spectral clustering algorithms!
                          </div>
                        </div>
                        
                        <div class="eigenvector-type">
                          <h6>Higher Eigenvectors (v‚ÇÉ, v‚ÇÑ, ...)</h6>
                          <p>
                            Reveal increasingly fine-grained structure: sub-communities, hierarchical organization, 
                            and complex flow patterns.
                          </p>
                        </div>
                      </div>
                    </div>

                    <div class="section">
                      <h5>The Discrete Laplace Equation</h5>
                      <p>
                        Eigenvectors solve: <strong>L v = Œª v</strong>
                      </p>
                      <p>
                        This is the discrete version of the Laplace equation from physics! It describes 
                        how "smoothly" values change across the graph. Higher eigenvalues correspond 
                        to more "oscillatory" patterns.
                      </p>
                    </div>
                  </div>

                  <!-- Chapter 5: Applications -->
                  <div class="chapter" id="applications-chapter">
                    <h4><span class="chapter-number">Chapter 5:</span> Real-World Applications</h4>
                    
                    <div class="application-detailed">
                      <h5>Google's PageRank Algorithm</h5>
                      <p>
                        The algorithm that built Google is fundamentally spectral graph theory!
                      </p>
                      <div class="algorithm-explanation">
                        <p>
                          PageRank finds the dominant eigenvector of the web graph's transition matrix. 
                          This eigenvector represents the "steady-state" probability that a random surfer 
                          visits each page.
                        </p>
                        <div class="algorithm-steps">
                          <div class="step">1. Build web graph (pages = nodes, links = edges)</div>
                          <div class="step">2. Create transition matrix from adjacency matrix</div>
                          <div class="step">3. Find dominant eigenvector using power iteration</div>
                          <div class="step">4. Eigenvector values = PageRank scores</div>
                        </div>
                      </div>
                    </div>

                    <div class="application-detailed">
                      <h5>Spectral Clustering</h5>
                      <p>
                        One of the most successful applications in machine learning and data science.
                      </p>
                      <div class="clustering-steps">
                        <div class="clustering-step">
                          <h6>Step 1: Build Similarity Graph</h6>
                          <p>Connect data points that are similar (k-NN, Œµ-neighborhood, or full graph with weights)</p>
                        </div>
                        <div class="clustering-step">
                          <h6>Step 2: Compute Laplacian</h6>
                          <p>Usually the normalized Laplacian: L = D‚Åª¬π/¬≤(D-A)D‚Åª¬π/¬≤</p>
                        </div>
                        <div class="clustering-step">
                          <h6>Step 3: Find Eigenvectors</h6>
                          <p>Compute first k eigenvectors for k clusters</p>
                        </div>
                        <div class="clustering-step">
                          <h6>Step 4: Cluster in Spectral Space</h6>
                          <p>Use k-means on the eigenvector matrix rows</p>
                        </div>
                      </div>
                    </div>

                    <div class="application-detailed">
                      <h5>Network Analysis & Social Media</h5>
                      <ul>
                        <li><strong>Community Detection:</strong> Find natural groups in social networks</li>
                        <li><strong>Influence Analysis:</strong> Identify key influencers using centrality measures</li>
                        <li><strong>Recommendation Systems:</strong> Predict connections and content preferences</li>
                        <li><strong>Anomaly Detection:</strong> Spot unusual patterns in network behavior</li>
                      </ul>
                    </div>

                    <div class="application-detailed">
                      <h5>Emerging Applications</h5>
                      <div class="emerging-grid">
                        <div class="emerging-app">
                          <h6>Quantum Computing</h6>
                          <p>Quantum walks on graphs, optimization algorithms (QAOA), and quantum machine learning</p>
                        </div>
                        <div class="emerging-app">
                          <h6>Deep Learning</h6>
                          <p>Graph Neural Networks (GNNs) use spectral concepts for learning on graph-structured data</p>
                        </div>
                        <div class="emerging-app">
                          <h6>Computational Biology</h6>
                          <p>Protein interaction networks, metabolic pathways, and gene regulatory networks</p>
                        </div>
                        <div class="emerging-app">
                          <h6>Transportation</h6>
                          <p>Route optimization, traffic flow analysis, and smart city infrastructure</p>
                        </div>
                      </div>
                    </div>
                  </div>

                  <!-- Chapter 6: Advanced Topics -->
                  <div class="chapter" id="advanced-chapter">
                    <h4><span class="chapter-number">Chapter 6:</span> Advanced Topics</h4>
                    
                    <div class="section">
                      <h5>Variations of the Laplacian</h5>
                      <div class="laplacian-variants">
                        <div class="variant">
                          <h6>Normalized Laplacian</h6>
                          <p>L_norm = D‚Åª¬π/¬≤LD‚Åª¬π/¬≤ = I - D‚Åª¬π/¬≤AD‚Åª¬π/¬≤</p>
                          <p>Better for graphs with varying degrees. Eigenvalues in [0, 2].</p>
                        </div>
                        <div class="variant">
                          <h6>Random Walk Laplacian</h6>
                          <p>L_rw = D‚Åª¬πL = I - D‚Åª¬πA</p>
                          <p>Directly related to random walks on the graph.</p>
                        </div>
                        <div class="variant">
                          <h6>Signless Laplacian</h6>
                          <p>Q = D + A</p>
                          <p>Used when edge orientations don't matter.</p>
                        </div>
                      </div>
                    </div>

                    <div class="section">
                      <h5>Graph Signal Processing</h5>
                      <p>
                        A modern extension where we analyze "signals" (functions) defined on graph vertices. 
                        The eigenvectors of the Laplacian form a "Fourier basis" for the graph!
                      </p>
                      <ul>
                        <li><strong>Graph Fourier Transform:</strong> Decompose signals into spectral components</li>
                        <li><strong>Graph Filtering:</strong> Remove noise or extract features from graph signals</li>
                        <li><strong>Applications:</strong> Sensor networks, image processing on meshes, social signal analysis</li>
                      </ul>
                    </div>

                    <div class="section">
                      <h5>Open Research Questions</h5>
                      <div class="research-questions">
                        <div class="question">
                          <h6>Inverse Eigenvalue Problems</h6>
                          <p>Given desired eigenvalues, can we construct a graph that realizes them? (What you're exploring in this tool!)</p>
                        </div>
                        <div class="question">
                          <h6>Dynamic Graphs</h6>
                          <p>How do spectral properties change as graphs evolve over time?</p>
                        </div>
                        <div class="question">
                          <h6>Multilayer Networks</h6>
                          <p>Extending spectral theory to graphs with multiple types of connections</p>
                        </div>
                        <div class="question">
                          <h6>Quantum Graphs</h6>
                          <p>Spectral theory on quantum mechanical graph structures</p>
                        </div>
                      </div>
                    </div>

                    <div class="section">
                      <h5>Going Deeper</h5>
                      <p>Ready to dive into the mathematics? Here are essential resources:</p>
                      <div class="resources">
                        <div class="resource-category">
                          <h6>Foundational Books</h6>
                          <ul>
                            <li>"Spectral Graph Theory" by Fan Chung</li>
                            <li>"Algebraic Graph Theory" by Chris Godsil & Gordon Royle</li>
                            <li>"Networks, Crowds, and Markets" by Easley & Kleinberg</li>
                          </ul>
                        </div>
                        <div class="resource-category">
                          <h6>Research Papers</h6>
                          <ul>
                            <li>Fiedler's original papers on algebraic connectivity</li>
                            <li>Spielman & Teng on graph sparsification</li>
                            <li>Von Luxburg's tutorial on spectral clustering</li>
                          </ul>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="info-panel">
            <div class="info-title">Experiment and Explore!</div>
            <div class="info-text">
              Try adjusting the properties above and watch how the eigenvalue spectrum changes. 
              Notice how different network types have characteristic "fingerprints" in their eigenvalues.
              Switch to the vibration patterns to see how information naturally flows through your network.
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    // graph-laplacian-engine.js - Core mathematical operations
    class GraphLaplacianEngine {
      constructor() {
        this.tolerance = 1e-10;
        this.maxIterations = 1000;
      }

      // Generate eigenvalues for common graph types
      getPresetEigenvalues(type, n) {
        switch(type) {
          case 'path':
            return this.pathGraphEigenvalues(n);
          case 'cycle':
            return this.cycleGraphEigenvalues(n);
          case 'complete':
            return this.completeGraphEigenvalues(n);
          case 'star':
            return this.starGraphEigenvalues(n);
          case 'wheel':
            return this.wheelGraphEigenvalues(n);
          case 'random':
            return this.randomValidEigenvalues(n);
          default:
            return new Array(n).fill(0).map((_, i) => i);
        }
      }

      pathGraphEigenvalues(n) {
        const eigenvals = [0]; // First eigenvalue is always 0
        for (let k = 1; k < n; k++) {
          eigenvals.push(2 - 2 * Math.cos((k * Math.PI) / (n + 1)));
        }
        return eigenvals.sort((a, b) => a - b);
      }

      cycleGraphEigenvalues(n) {
        const eigenvals = [];
        for (let k = 0; k < n; k++) {
          eigenvals.push(2 - 2 * Math.cos((2 * Math.PI * k) / n));
        }
        return eigenvals.sort((a, b) => a - b);
      }

      completeGraphEigenvalues(n) {
        const eigenvals = [0];
        for (let i = 1; i < n; i++) {
          eigenvals.push(n);
        }
        return eigenvals;
      }

      starGraphEigenvalues(n) {
        const eigenvals = [0, 1];
        for (let i = 2; i < n; i++) {
          eigenvals.push(1);
        }
        eigenvals[n - 1] = n;
        return eigenvals.sort((a, b) => a - b);
      }

      wheelGraphEigenvalues(n) {
        // Wheel graph: cycle + center node
        const cycleEigenvals = this.cycleGraphEigenvalues(n - 1);
        return [0, ...cycleEigenvals.slice(1).map(x => x + 1), n];
      }

      randomValidEigenvalues(n) {
        // Generate random but valid eigenvalue set
        const eigenvals = [0]; // Always start with 0
        for (let i = 1; i < n; i++) {
          eigenvals.push(Math.random() * 4 + 0.1);
        }
        return eigenvals.sort((a, b) => a - b);
      }

      // Check if eigenvalues are valid for a graph
      validateEigenvalues(eigenvals) {
        const n = eigenvals.length;
        
        // Basic checks
        if (Math.abs(eigenvals[0]) > this.tolerance) {
          return { valid: false, reason: "First eigenvalue must be 0 (connected components)" };
        }

        for (let i = 0; i < n - 1; i++) {
          if (eigenvals[i] > eigenvals[i + 1] + this.tolerance) {
            return { valid: false, reason: "Eigenvalues must be in non-decreasing order" };
          }
        }

        // Check for disconnected graph (multiple zero eigenvalues)
        let zeroCount = 0;
        for (let i = 0; i < n; i++) {
          if (Math.abs(eigenvals[i]) < this.tolerance) zeroCount++;
        }
        
        if (zeroCount > 1) {
          return { valid: false, reason: `Graph has ${zeroCount} connected components` };
        }

        // Check algebraic connectivity
        if (eigenvals[1] < this.tolerance && n > 1) {
          return { valid: false, reason: "Graph is disconnected (algebraic connectivity = 0)" };
        }

        // Advanced checks: interlacing properties and realizability
        const confidence = this.computeConfidence(eigenvals);
        const realizability = this.checkRealizability(eigenvals);
        
        if (realizability.realizable) {
          return { valid: true, confidence, graphType: realizability.graphType };
        } else {
          return { 
            valid: false, 
            reason: realizability.reason,
            confidence: confidence * 0.5 // Partially valid but not realizable
          };
        }
      }

      checkRealizability(eigenvals) {
        const n = eigenvals.length;
        
        // Check against known graph families
        const tolerance = 0.05;
        
        // Path graph check
        const pathEigenvals = this.pathGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, pathEigenvals, tolerance)) {
          return { realizable: true, graphType: 'path' };
        }
        
        // Cycle graph check
        const cycleEigenvals = this.cycleGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, cycleEigenvals, tolerance)) {
          return { realizable: true, graphType: 'cycle' };
        }
        
        // Complete graph check
        const completeEigenvals = this.completeGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, completeEigenvals, tolerance)) {
          return { realizable: true, graphType: 'complete' };
        }
        
        // Star graph check
        const starEigenvals = this.starGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, starEigenvals, tolerance)) {
          return { realizable: true, graphType: 'star' };
        }
        
        // General realizability heuristics
        const maxPossibleEigenvalue = 2 * n; // Upper bound for regular graphs
        if (eigenvals[n - 1] > maxPossibleEigenvalue) {
          return { 
            realizable: false, 
            reason: `Max eigenvalue ${eigenvals[n - 1].toFixed(2)} exceeds theoretical bound ${maxPossibleEigenvalue}` 
          };
        }
        
        // Check eigenvalue gaps (very large gaps are suspicious)
        for (let i = 1; i < n - 1; i++) {
          const gap = eigenvals[i + 1] - eigenvals[i];
          if (gap > n) {
            return { 
              realizable: false, 
              reason: `Unusually large eigenvalue gap (${gap.toFixed(2)}) between Œª${i+1} and Œª${i+2}` 
            };
          }
        }
        
        return { realizable: true, graphType: 'general' };
      }

      eigenvaluesMatch(eigenvals1, eigenvals2, tolerance) {
        if (eigenvals1.length !== eigenvals2.length) return false;
        
        for (let i = 0; i < eigenvals1.length; i++) {
          if (Math.abs(eigenvals1[i] - eigenvals2[i]) > tolerance) return false;
        }
        return true;
      }

      computeConfidence(eigenvals) {
        // Heuristic to determine how "graph-like" the eigenvalues are
        const n = eigenvals.length;
        let score = 1.0;

        // Penalize very large gaps
        for (let i = 1; i < n - 1; i++) {
          const gap = eigenvals[i + 1] - eigenvals[i];
          if (gap > 3) score *= 0.8;
        }

        // Penalize very large eigenvalues
        const maxEigenval = eigenvals[n - 1];
        if (maxEigenval > 2 * n) score *= 0.7;

        return Math.max(0.1, Math.min(1.0, score));
      }

      // Project invalid eigenvalues to nearest valid set
      projectToValidEigenvalues(eigenvals) {
        const projected = [...eigenvals].sort((a, b) => a - b);
        projected[0] = 0; // Ensure first eigenvalue is 0
        
        // Ensure non-negativity
        for (let i = 0; i < projected.length; i++) {
          projected[i] = Math.max(0, projected[i]);
        }

        // Ensure algebraic connectivity > 0 (except for disconnected graphs)
        if (projected.length > 1 && projected[1] < 0.01) {
          projected[1] = 0.1;
        }

        return projected;
      }

      // Generate approximate graph from eigenvalues
      generateGraphFromEigenvalues(eigenvals) {
        const n = eigenvals.length;
        const positions = this.generateSpectralPositions(eigenvals);
        const adjacency = this.constructAdjacencyMatrix(eigenvals, positions);
        
        return {
          positions,
          adjacency,
          eigenvalues: eigenvals,
          properties: this.computeGraphProperties(eigenvals)
        };
      }

      generateSpectralPositions(eigenvals) {
        const n = eigenvals.length;
        const positions = [];
        
        // Use first few eigenvalues to determine 2D embedding
        for (let i = 0; i < n; i++) {
          const angle = (2 * Math.PI * i) / n;
          const radius = 150 + 50 * Math.sin(eigenvals[Math.min(i, eigenvals.length - 1)]);
          
          positions.push({
            x: 300 + radius * Math.cos(angle),
            y: 300 + radius * Math.sin(angle)
          });
        }
        
        return positions;
      }

      constructAdjacencyMatrix(eigenvals, positions) {
        const n = eigenvals.length;
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        
        // Determine graph type based on eigenvalue pattern
        const graphType = this.detectGraphType(eigenvals);
        
        switch(graphType) {
          case 'path':
            return this.createPathAdjacency(n);
          case 'cycle':
            return this.createCycleAdjacency(n);
          case 'complete':
            return this.createCompleteAdjacency(n);
          case 'star':
            return this.createStarAdjacency(n);
          default:
            return this.createHeuristicAdjacency(eigenvals, positions);
        }
      }

      detectGraphType(eigenvals) {
        const n = eigenvals.length;
        const tolerance = 0.1;
        
        // Check for path graph pattern
        const pathEigenvals = this.pathGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, pathEigenvals, tolerance)) return 'path';
        
        // Check for cycle graph pattern  
        const cycleEigenvals = this.cycleGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, cycleEigenvals, tolerance)) return 'cycle';
        
        // Check for complete graph pattern
        const completeEigenvals = this.completeGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, completeEigenvals, tolerance)) return 'complete';
        
        // Check for star graph pattern
        const starEigenvals = this.starGraphEigenvalues(n);
        if (this.eigenvaluesMatch(eigenvals, starEigenvals, tolerance)) return 'star';
        
        return 'unknown';
      }

      eigenvaluesMatch(eigenvals1, eigenvals2, tolerance) {
        if (eigenvals1.length !== eigenvals2.length) return false;
        
        for (let i = 0; i < eigenvals1.length; i++) {
          if (Math.abs(eigenvals1[i] - eigenvals2[i]) > tolerance) return false;
        }
        return true;
      }

      createPathAdjacency(n) {
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        for (let i = 0; i < n - 1; i++) {
          adjacency[i][i + 1] = adjacency[i + 1][i] = 1;
        }
        return adjacency;
      }

      createCycleAdjacency(n) {
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        for (let i = 0; i < n - 1; i++) {
          adjacency[i][i + 1] = adjacency[i + 1][i] = 1;
        }
        adjacency[0][n - 1] = adjacency[n - 1][0] = 1;
        return adjacency;
      }

      createCompleteAdjacency(n) {
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            adjacency[i][j] = adjacency[j][i] = 1;
          }
        }
        return adjacency;
      }

      createStarAdjacency(n) {
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        // Connect all nodes to node 0 (center)
        for (let i = 1; i < n; i++) {
          adjacency[0][i] = adjacency[i][0] = 1;
        }
        return adjacency;
      }

      createHeuristicAdjacency(eigenvals, positions) {
        const n = eigenvals.length;
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            const spectralDistance = this.computeSpectralDistance(i, j, eigenvals);
            const probability = Math.exp(-spectralDistance);
            
            if (probability > 0.3) {
              adjacency[i][j] = adjacency[j][i] = 1;
            }
          }
        }
        
        return adjacency;
      }

      computeSpectralDistance(i, j, eigenvals) {
        // Simplified spectral distance measure
        const n = eigenvals.length;
        let distance = 0;
        
        for (let k = 1; k < Math.min(4, n); k++) {
          const eigenval = eigenvals[k];
          if (eigenval > 1e-6) {
            distance += Math.abs(Math.cos(2 * Math.PI * k * i / n) - 
                               Math.cos(2 * Math.PI * k * j / n)) / eigenval;
          }
        }
        
        return distance;
      }

      computeGraphProperties(eigenvals) {
        const n = eigenvals.length;
        return {
          spectralGap: eigenvals[1] - eigenvals[0],
          algebraicConnectivity: eigenvals[1],
          maxEigenvalue: eigenvals[n - 1],
          eigenvalueSum: eigenvals.reduce((a, b) => a + b, 0)
        };
      }
    }

    // graph-visualizer.js - Canvas-based graph rendering
    class GraphVisualizer {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.setupCanvas();
        this.animationFrame = null;
        
        // Visual settings
        this.nodeRadius = 12;
        this.nodeColor = '#6366f1';
        this.nodeStroke = '#ffffff';
        this.edgeColor = '#cbd5e1';
        this.edgeWidth = 2;
        this.selectedColor = '#ec4899';
        
        // Interaction
        this.isDragging = false;
        this.dragNode = null;
        this.mousePos = { x: 0, y: 0 };
        
        this.setupInteraction();
      }

      setupCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
      }

      setupInteraction() {
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
        this.canvas.addEventListener('mouseleave', () => this.handleMouseUp());
      }

      handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.mousePos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };

        if (this.graph) {
          const clickedNode = this.getNodeAtPosition(this.mousePos);
          if (clickedNode !== -1) {
            this.isDragging = true;
            this.dragNode = clickedNode;
          }
        }
      }

      handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.mousePos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };

        if (this.isDragging && this.dragNode !== null && this.graph) {
          this.graph.positions[this.dragNode] = { ...this.mousePos };
          this.render();
        }
      }

      handleMouseUp() {
        this.isDragging = false;
        this.dragNode = null;
      }

      getNodeAtPosition(pos) {
        if (!this.graph) return -1;
        
        for (let i = 0; i < this.graph.positions.length; i++) {
          const node = this.graph.positions[i];
          const dx = pos.x - node.x;
          const dy = pos.y - node.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= this.nodeRadius + 5) {
            return i;
          }
        }
        
        return -1;
      }

      setGraph(graph) {
        this.graph = graph;
        this.render();
      }

      render() {
        if (!this.graph) return;

        const ctx = this.ctx;
        const rect = this.canvas.getBoundingClientRect();
        
        // Clear canvas
        ctx.clearRect(0, 0, rect.width, rect.height);
        
        // Draw edges
        this.drawEdges();
        
        // Draw nodes
        this.drawNodes();
        
        // Draw labels
        this.drawLabels();
      }

      drawEdges() {
        const ctx = this.ctx;
        const { positions, adjacency } = this.graph;
        
        ctx.strokeStyle = this.edgeColor;
        ctx.lineWidth = this.edgeWidth;
        
        for (let i = 0; i < positions.length; i++) {
          for (let j = i + 1; j < positions.length; j++) {
            if (adjacency[i][j]) {
              ctx.beginPath();
              ctx.moveTo(positions[i].x, positions[i].y);
              ctx.lineTo(positions[j].x, positions[j].y);
              ctx.stroke();
            }
          }
        }
      }

      drawNodes() {
        const ctx = this.ctx;
        const { positions } = this.graph;
        
        positions.forEach((pos, i) => {
          const isHovered = this.getNodeAtPosition(this.mousePos) === i;
          const isDragged = this.dragNode === i;
          
          // Node shadow
          ctx.beginPath();
          ctx.arc(pos.x + 2, pos.y + 2, this.nodeRadius, 0, 2 * Math.PI);
          ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
          ctx.fill();
          
          // Node body
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, this.nodeRadius, 0, 2 * Math.PI);
          ctx.fillStyle = (isHovered || isDragged) ? this.selectedColor : this.nodeColor;
          ctx.fill();
          
          // Node border
          ctx.strokeStyle = this.nodeStroke;
          ctx.lineWidth = 3;
          ctx.stroke();
        });
      }

      drawLabels() {
        const ctx = this.ctx;
        const { positions } = this.graph;
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 10px Inter';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        positions.forEach((pos, i) => {
          ctx.fillText(i.toString(), pos.x, pos.y);
        });
      }

      updateProperties(properties) {
        document.getElementById('spectral-gap').textContent = 
          properties.spectralGap.toFixed(3);
        document.getElementById('algebraic-connectivity').textContent = 
          properties.algebraicConnectivity.toFixed(3);
      }
    }

    // eigenvalue-controls.js - Interactive UI components
    class EigenvalueControls {
      constructor(container, onChange) {
        this.container = container;
        this.onChange = onChange;
        this.nodeCount = 5;
        this.eigenvalues = [0, 0.5, 1.0, 1.5, 2.0];
        this.setupControls();
      }

      setupControls() {
        this.renderSliders();
        this.setupPresets();
        this.setupNodeCountControl();
      }

      renderSliders() {
        this.container.innerHTML = '';
        
        this.eigenvalues.forEach((value, index) => {
          const controlDiv = document.createElement('div');
          controlDiv.className = 'eigenvalue-control';
          
          controlDiv.innerHTML = `
            <div class="eigenvalue-label">
              <span>Œª${index + 1}</span>
              <span class="eigenvalue-value">${value.toFixed(3)}</span>
            </div>
            <input type="range" 
                   class="eigenvalue-slider" 
                   id="eigenvalue-${index}"
                   min="0" 
                   max="5" 
                   step="0.01" 
                   value="${value}"
                   ${index === 0 ? 'disabled' : ''}>
          `;
          
          this.container.appendChild(controlDiv);
          
          const slider = controlDiv.querySelector('.eigenvalue-slider');
          const valueSpan = controlDiv.querySelector('.eigenvalue-value');
          
          slider.addEventListener('input', (e) => {
            const newValue = parseFloat(e.target.value);
            this.eigenvalues[index] = newValue;
            valueSpan.textContent = newValue.toFixed(3);
            this.onChange(this.eigenvalues);
          });
        });
      }

      setupPresets() {
        const presetButtons = document.querySelectorAll('.preset-btn');
        presetButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const preset = btn.dataset.preset;
            const engine = new GraphLaplacianEngine();
            this.eigenvalues = engine.getPresetEigenvalues(preset, this.nodeCount);
            this.updateSliders();
            this.onChange(this.eigenvalues);
          });
        });
      }

      setupNodeCountControl() {
        const nodeCountSelect = document.getElementById('node-count');
        nodeCountSelect.addEventListener('change', (e) => {
          this.nodeCount = parseInt(e.target.value);
          this.eigenvalues = new Array(this.nodeCount).fill(0).map((_, i) => i * 0.5);
          this.renderSliders();
          this.onChange(this.eigenvalues);
        });
      }

      updateSliders() {
        this.eigenvalues.forEach((value, index) => {
          const slider = document.getElementById(`eigenvalue-${index}`);
          const valueSpan = slider.parentElement.querySelector('.eigenvalue-value');
          if (slider) {
            slider.value = value;
            valueSpan.textContent = value.toFixed(3);
          }
        });
      }

      setEigenvalues(eigenvalues) {
        this.eigenvalues = [...eigenvalues];
        this.updateSliders();
      }
    }

    // main-applet.js - Orchestration and state management
    class GraphLaplacianApplet {
      constructor() {
        this.engine = new GraphLaplacianEngine();
        this.visualizer = null;
        this.controls = null;
        this.eigenvalueChart = null;
        this.eigenvectorVisualizer = null;
        this.currentGraph = null;
        this.worker = null;
        
        this.init();
      }

      async init() {
        console.log('GraphLaplacianApplet.init() starting');
        
        // Setup visualizer
        const canvas = document.getElementById('graph-canvas');
        console.log('Canvas element:', canvas);
        
        if (!canvas) {
          console.error('Canvas element not found!');
          return;
        }
        
        this.visualizer = new GraphVisualizer(canvas);
        
        // Setup eigenvalue chart
        const chartCanvas = document.getElementById('eigenvalue-chart');
        console.log('Chart canvas element:', chartCanvas);
        
        if (chartCanvas) {
          this.eigenvalueChart = new EigenvalueChart(chartCanvas);
        }
        
        // Setup eigenvector visualizer
        this.eigenvectorVisualizer = new EigenvectorVisualizer(this.visualizer);
        
        // Setup intuitive property controls
        console.log('Setting up property controls');
        this.controls = new PropertyControls(
          (eigenvalues) => this.onEigenvaluesChanged(eigenvalues)
        );
        
        // Setup tabs
        this.setupTabs();
        
        // Setup eigenvector controls
        this.setupEigenvectorControls();
        
        // Setup worker for heavy computations
        this.setupWorker();
        
        // Force initial graph generation for testing
        this.generateInitialGraph();
        
        // Initial graph - the PropertyControls will trigger this automatically
        console.log('Initialization complete');
        
        // Handle window resize
        window.addEventListener('resize', () => {
          this.visualizer.setupCanvas();
          if (this.eigenvalueChart) {
            this.eigenvalueChart.setupCanvas();
          }
          this.visualizer.render();
          if (this.eigenvalueChart) {
            this.eigenvalueChart.render();
          }
        });
      }

      setupTabs() {
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabPanels = document.querySelectorAll('.tab-panel');
        
        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            const targetTab = button.dataset.tab;
            
            // Update button states
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            
            // Update panel visibility
            tabPanels.forEach(panel => panel.classList.remove('active'));
            const targetPanel = document.getElementById(`${targetTab}-panel`);
            if (targetPanel) {
              targetPanel.classList.add('active');
            }
            
            // Clear eigenvector colors when switching away from eigenvectors tab
            if (targetTab !== 'eigenvectors') {
              this.visualizer.clearEigenvectorColors();
            } else {
              // Update eigenvector visualization when switching to it
              this.eigenvectorVisualizer.updateVisualization();
            }
          });
        });

        // Setup textbook chapter navigation
        this.setupTextbookNavigation();
      }

      setupTextbookNavigation() {
        const chapterButtons = document.querySelectorAll('.chapter-btn');
        const chapters = document.querySelectorAll('.chapter');
        
        chapterButtons.forEach(button => {
          button.addEventListener('click', () => {
            const targetChapter = button.dataset.chapter;
            
            // Update button states
            chapterButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            
            // Update chapter visibility
            chapters.forEach(chapter => chapter.classList.remove('active'));
            const targetChapterEl = document.getElementById(`${targetChapter}-chapter`);
            if (targetChapterEl) {
              targetChapterEl.classList.add('active');
            }
          });
        });
      }

      setupEigenvectorControls() {
        const eigenvectorSelect = document.getElementById('eigenvector-select');
        const animateButton = document.getElementById('animate-pattern');
        
        eigenvectorSelect.addEventListener('change', (e) => {
          const selectedIndex = parseInt(e.target.value);
          this.eigenvectorVisualizer.setSelectedVector(selectedIndex);
        });
        
        animateButton.addEventListener('click', () => {
          this.eigenvectorVisualizer.animatePattern();
        });
      }

      setupWorker() {
        // For this demo, we'll compute synchronously for reliability
        // In production, this could use Web Workers for heavy computations
        this.worker = {
          postMessage: (data) => {
            console.log('Worker received message:', data);
            
            try {
              const result = this.engine.generateGraphFromEigenvalues(data.eigenvalues);
              console.log('Worker computed result:', result);
              
              // Call the message handler directly (simulating async worker)
              setTimeout(() => {
                this.onWorkerMessage({ data: result });
              }, 10);
            } catch (error) {
              console.error('Worker computation error:', error);
            }
          }
        };
        
        console.log('Worker setup complete');
      }

      onWorkerMessage(event) {
        const graph = event.data;
        this.currentGraph = graph;
        
        console.log('Graph generated:', graph); // Debug log
        
        // Update main graph visualization
        this.visualizer.setGraph(graph);
        this.visualizer.updateProperties(graph.properties);
        
        // Update eigenvalue chart
        this.eigenvalueChart.updateEigenvalues(graph.eigenvalues);
        
        // Update eigenvector visualization
        this.eigenvectorVisualizer.updateEigenvectors(graph.eigenvalues, graph);
        
        // Update insights
        this.updateEigenvalueInsights(graph.eigenvalues, graph.properties);
        
        // Update the explanation based on what we're showing
        this.updateDynamicExplanation(graph);
      }

      updateEigenvalueInsights(eigenvalues, properties) {
        // Update second eigenvalue meaning
        const secondEl = document.getElementById('second-eigenvalue-meaning');
        if (eigenvalues[1] > 2.0) {
          secondEl.textContent = "Strong connectivity - information flows quickly";
        } else if (eigenvalues[1] > 1.0) {
          secondEl.textContent = "Good connectivity - well-connected network";
        } else if (eigenvalues[1] > 0.3) {
          secondEl.textContent = "Moderate connectivity - some bottlenecks";
        } else {
          secondEl.textContent = "Weak connectivity - fragmented network";
        }
        
        // Update largest eigenvalue meaning
        const largestEl = document.getElementById('largest-eigenvalue-meaning');
        const largest = eigenvalues[eigenvalues.length - 1];
        const n = eigenvalues.length;
        
        if (largest > n) {
          largestEl.textContent = "High maximum degree - hub-like structure";
        } else if (largest > n * 0.7) {
          largestEl.textContent = "Moderate hubs present";
        } else {
          largestEl.textContent = "Uniform degree distribution";
        }
      }

      updateDynamicExplanation(graph) {
        const explanationEl = document.getElementById('explanation-text');
        const properties = this.controls.getProperties();
        const { spectralGap, algebraicConnectivity } = graph.properties;
        
        let explanation = `Your ${this.getGraphDescription(graph)} has `;
        
        if (algebraicConnectivity > 2.0) {
          explanation += "excellent connectivity - information flows quickly between all nodes. ";
        } else if (algebraicConnectivity > 1.0) {
          explanation += "good connectivity - most nodes can communicate efficiently. ";
        } else if (algebraicConnectivity > 0.3) {
          explanation += "moderate connectivity - some bottlenecks may exist. ";
        } else {
          explanation += "limited connectivity - the graph may have weak points. ";
        }
        
        explanation += `The network health score of ${spectralGap.toFixed(2)} indicates ${
          spectralGap > 1.0 ? "rapid information propagation and strong structural integrity" : 
          "slower information flow and potential structural weaknesses"
        }.`;
        
        explanationEl.innerHTML = explanation;
      }

      getGraphDescription(graph) {
        const validation = this.engine.validateEigenvalues(graph.eigenvalues);
        if (validation.valid && validation.graphType && validation.confidence > 0.9) {
          const typeNames = {
            path: "chain of connected nodes",
            cycle: "circular ring network", 
            complete: "fully connected network",
            star: "hub-and-spoke network"
          };
          return typeNames[validation.graphType] || "network";
        }
        return "network";
      }

      generateInitialGraph() {
        // Force an immediate test graph to verify the system works
        console.log('Generating initial test graph');
        
        const testEigenvalues = [0, 0.268, 1.000, 2.000, 3.732]; // Path graph eigenvalues
        console.log('Test eigenvalues:', testEigenvalues);
        
        setTimeout(() => {
          console.log('Triggering test graph generation');
          this.onEigenvaluesChanged(testEigenvalues);
        }, 500);
      }

      onEigenvaluesChanged(eigenvalues) {
        // Generate graph (via worker in production)
        this.worker.postMessage({ eigenvalues });
      }
    }

    // Initialize the applet when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      // Add canvas round rect polyfill for older browsers
      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
          this.beginPath();
          this.moveTo(x + radius, y);
          this.lineTo(x + width - radius, y);
          this.quadraticCurveTo(x + width, y, x + width, y + radius);
          this.lineTo(x + width, y + height - radius);
          this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
          this.lineTo(x + radius, y + height);
          this.quadraticCurveTo(x, y + height, x, y + height - radius);
          this.lineTo(x, y + radius);
          this.quadraticCurveTo(x, y, x + radius, y);
          this.closePath();
        };
      }
      
      console.log('Starting applet initialization'); // Debug log
      
      const applet = new GraphLaplacianApplet();
      window.graphLaplacianApplet = applet; // For debugging
    });
  </script>
</body>
</html>