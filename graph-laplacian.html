<!-- graph-laplacian.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Interactive guide to spectral graph theory - learn by exploring!">
  <title>The Hidden Mathematics of Networks ‚Äî Jack Kinney</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --secondary: #ec4899;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;

      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-card: #ffffff;
      --text-primary: #0f172a;
      --text-secondary: #475569;
      --text-muted: #64748b;
      --border: #e2e8f0;

      --space-2: 0.5rem;
      --space-3: 0.75rem;
      --space-4: 1rem;
      --space-6: 1.5rem;
      --space-8: 2rem;
      --space-12: 3rem;
      --space-16: 4rem;

      --font-sans: 'Inter', system-ui, sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
      --radius: 0.5rem;
      --radius-lg: 1rem;
      --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
      --transition: all 0.3s ease;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-sans);
      line-height: 1.7;
      color: var(--text-primary);
      background: var(--bg-primary);
    }

    /* Blog-style layout */
    .blog-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 0 var(--space-6);
    }

    .wide-container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 0 var(--space-6);
    }

    /* Header */
    .header {
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border);
      padding: var(--space-4) 0;
      position: sticky;
      top: 0;
      z-index: 100;
      backdrop-filter: blur(20px);
    }

    .header-content {
      max-width: 1000px;
      margin: 0 auto;
      padding: 0 var(--space-6);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--text-primary);
      font-family: var(--font-mono);
      text-decoration: none;
    }

    .back-link {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      color: var(--primary);
      text-decoration: none;
      font-weight: 500;
    }

    /* Typography */
    .blog-title {
      font-size: 3rem;
      font-weight: 800;
      line-height: 1.2;
      margin: var(--space-12) 0 var(--space-6);
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-align: center;
    }

    .blog-subtitle {
      font-size: 1.25rem;
      color: var(--text-secondary);
      text-align: center;
      margin-bottom: var(--space-16);
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .section-title {
      font-size: 2rem;
      font-weight: 700;
      margin: var(--space-16) 0 var(--space-6);
      color: var(--text-primary);
    }

    .subsection-title {
      font-size: 1.5rem;
      font-weight: 600;
      margin: var(--space-12) 0 var(--space-4);
      color: var(--primary);
    }

    p {
      margin-bottom: var(--space-6);
      font-size: 1.1rem;
    }

    /* Interactive components */
    .interactive-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--space-8);
      margin: var(--space-8) 0;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-6);
      margin-bottom: var(--space-8);
    }

    .control-group {
      background: white;
      padding: var(--space-4);
      border-radius: var(--radius);
      border: 1px solid var(--border);
    }

    .control-label {
      font-weight: 600;
      margin-bottom: var(--space-2);
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.9rem;
    }

    .control-label i {
      color: var(--text-muted);
      cursor: help;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      margin-bottom: var(--space-2);
    }

    .slider {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: #e2e8f0;
      outline: none;
      -webkit-appearance: none;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: var(--shadow);
    }

    .slider-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      white-space: nowrap;
    }

    .control-value {
      text-align: center;
      font-size: 0.85rem;
      color: var(--primary);
      font-weight: 600;
      background: rgba(99, 102, 241, 0.1);
      padding: var(--space-2);
      border-radius: var(--radius);
    }

    /* Graph visualization */
    .graph-section {
      background: white;
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--space-6);
      margin: var(--space-8) 0;
    }

    .graph-container {
      position: relative;
      height: 500px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: linear-gradient(45deg, #f8fafc 25%, transparent 25%), 
                  linear-gradient(-45deg, #f8fafc 25%, transparent 25%), 
                  linear-gradient(45deg, transparent 75%, #f8fafc 75%), 
                  linear-gradient(-45deg, transparent 75%, #f8fafc 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
      margin-bottom: var(--space-6);
    }

    #graph-canvas {
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #graph-canvas:active {
      cursor: grabbing;
    }

    .graph-info {
      position: absolute;
      top: var(--space-3);
      right: var(--space-3);
      background: rgba(255, 255, 255, 0.95);
      padding: var(--space-3);
      border-radius: var(--radius);
      font-size: 0.85rem;
      border: 1px solid var(--border);
    }

    .graph-controls {
      position: absolute;
      top: var(--space-3);
      left: var(--space-3);
      display: flex;
      gap: var(--space-2);
    }

    .graph-btn {
      background: var(--primary);
      color: white;
      border: none;
      padding: var(--space-2) var(--space-3);
      border-radius: var(--radius);
      font-size: 0.8rem;
      cursor: pointer;
      transition: var(--transition);
    }

    .graph-btn:hover {
      background: var(--primary-dark);
    }

    .graph-btn.active {
      background: var(--secondary);
    }

    /* Chart */
    .chart-container {
      background: var(--bg-secondary);
      padding: var(--space-4);
      border-radius: var(--radius);
      border: 1px solid var(--border);
    }

    .chart-title {
      font-weight: 600;
      margin-bottom: var(--space-3);
      text-align: center;
    }

    .chart-canvas-container {
      height: 200px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Presets */
    .presets-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: var(--space-3);
      margin: var(--space-6) 0;
    }

    .preset-btn {
      background: white;
      border: 2px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-4);
      cursor: pointer;
      transition: var(--transition);
      text-align: center;
    }

    .preset-btn:hover {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
      transform: translateY(-2px);
    }

    .preset-btn.active {
      border-color: var(--primary);
      background: var(--primary);
      color: white;
    }

    .preset-icon {
      font-size: 1.5rem;
      margin-bottom: var(--space-2);
      color: var(--primary);
    }

    .preset-btn.active .preset-icon {
      color: white;
    }

    .preset-name {
      font-weight: 600;
      margin-bottom: var(--space-1);
    }

    .preset-desc {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .preset-btn.active .preset-desc {
      color: rgba(255, 255, 255, 0.8);
    }

    /* Vibration visualization */
    .vibration-controls {
      display: flex;
      gap: var(--space-4);
      align-items: center;
      margin-bottom: var(--space-6);
      flex-wrap: wrap;
    }

    .vibration-select {
      padding: var(--space-2) var(--space-3);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: white;
    }

    .animate-btn {
      background: var(--success);
      color: white;
      border: none;
      padding: var(--space-2) var(--space-4);
      border-radius: var(--radius);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: var(--space-2);
      transition: var(--transition);
    }

    .animate-btn:hover {
      background: #059669;
    }

    .animate-btn.playing {
      background: var(--danger);
    }

    /* Insights */
    .insights-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-3);
      margin: var(--space-6) 0;
    }

    .insight-card {
      background: white;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-4);
      text-align: center;
    }

    .insight-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--primary);
      margin-bottom: var(--space-2);
    }

    .insight-label {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    /* Callout boxes */
    .callout {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(236, 72, 153, 0.1));
      border-left: 4px solid var(--primary);
      padding: var(--space-4);
      margin: var(--space-6) 0;
      border-radius: 0 var(--radius) var(--radius) 0;
    }

    .callout-title {
      font-weight: 600;
      margin-bottom: var(--space-2);
      color: var(--primary);
    }

    /* Settings */
    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--space-4);
    }

    .settings-row select {
      padding: var(--space-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: white;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .blog-title {
        font-size: 2rem;
      }
      
      .blog-container,
      .wide-container {
        padding: 0 var(--space-4);
      }
      
      .controls-grid {
        grid-template-columns: 1fr;
      }
      
      .graph-container {
        height: 400px;
      }
      
      .presets-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* Animations */
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .pulsing {
      animation: pulse 1s infinite;
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="header-content">
      <a href="./index.html" class="logo">&lt;JTK/&gt;</a>
      <a href="./projects.html" class="back-link">
        <i class="fas fa-arrow-left"></i>
        Back to Projects
      </a>
    </div>
  </header>

  <main>
    <div class="blog-container">
      <h1 class="blog-title">The Hidden Mathematics of Networks</h1>
      <p class="blog-subtitle">
        üéµ Every network has a secret mathematical "song" ‚Äî let's learn to hear it together! 
        No equations required, just curiosity and a willingness to explore.
      </p>

      <p>
        You use networks every day. When you search Google, scroll through social media, or get GPS directions, 
        you're benefiting from a beautiful branch of mathematics called <strong>spectral graph theory</strong>. 
        It reveals the hidden patterns and structures that make networks tick.
      </p>

      <p>
        Think of it like this: if your network were a guitar string, spectral graph theory tells us about its 
        natural "vibration patterns" and "musical notes." These mathematical properties determine how information 
        flows, how robust the network is, and how communities form within it.
      </p>

      <div class="callout">
        <div class="callout-title">üéØ What You'll Discover</div>
        By the end of this interactive guide, you'll understand how networks have mathematical "fingerprints" 
        and how changing simple properties creates completely different structures. You'll see the same patterns 
        that power Google's search algorithm, social media recommendation systems, and brain network analysis.
      </div>

      <h2 class="section-title">üöÄ Let's Start Simple</h2>
      
      <p>
        Instead of throwing equations at you, let's start with intuitive properties. Below are five sliders 
        that control different aspects of your network. As you adjust them, watch how the mathematics 
        responds automatically!
      </p>

      <div class="interactive-section">
        <h3 style="margin-bottom: var(--space-6); text-align: center;">üéõÔ∏è Network Property Controls</h3>
        
        <div class="controls-grid">
          <div class="control-group">
            <div class="control-label">
              <span>Connectivity</span>
              <i class="fas fa-question-circle" title="How well-connected nodes are overall"></i>
            </div>
            <div class="slider-container">
              <span class="slider-label">Sparse</span>
              <input type="range" class="slider" id="connectivity-slider" min="0" max="100" value="50">
              <span class="slider-label">Dense</span>
            </div>
            <div class="control-value" id="connectivity-value">Moderate</div>
          </div>

          <div class="control-group">
            <div class="control-label">
              <span>Clustering</span>
              <i class="fas fa-question-circle" title="How much nodes form tight groups"></i>
            </div>
            <div class="slider-container">
              <span class="slider-label">Uniform</span>
              <input type="range" class="slider" id="clustering-slider" min="0" max="100" value="30">
              <span class="slider-label">Clustered</span>
            </div>
            <div class="control-value" id="clustering-value">Low</div>
          </div>

          <div class="control-group">
            <div class="control-label">
              <span>Regularity</span>
              <i class="fas fa-question-circle" title="Uniform vs hub-and-spoke structure"></i>
            </div>
            <div class="slider-container">
              <span class="slider-label">Hubs</span>
              <input type="range" class="slider" id="regularity-slider" min="0" max="100" value="60">
              <span class="slider-label">Uniform</span>
            </div>
            <div class="control-value" id="regularity-value">Balanced</div>
          </div>

          <div class="control-group">
            <div class="control-label">
              <span>Locality</span>
              <i class="fas fa-question-circle" title="Local vs long-distance connections"></i>
            </div>
            <div class="slider-container">
              <span class="slider-label">Global</span>
              <input type="range" class="slider" id="locality-slider" min="0" max="100" value="70">
              <span class="slider-label">Local</span>
            </div>
            <div class="control-value" id="locality-value">Mostly local</div>
          </div>

          <div class="control-group">
            <div class="control-label">
              <span>Symmetry</span>
              <i class="fas fa-question-circle" title="Random vs organized structure"></i>
            </div>
            <div class="slider-container">
              <span class="slider-label">Random</span>
              <input type="range" class="slider" id="symmetry-slider" min="0" max="100" value="50">
              <span class="slider-label">Symmetric</span>
            </div>
            <div class="control-value" id="symmetry-value">Balanced</div>
          </div>

          <div class="control-group">
            <div class="settings-row">
              <span>Network size:</span>
              <select id="node-count">
                <option value="4">4 nodes</option>
                <option value="5" selected>5 nodes</option>
                <option value="6">6 nodes</option>
                <option value="7">7 nodes</option>
                <option value="8">8 nodes</option>
                <option value="10">10 nodes</option>
              </select>
            </div>
          </div>
        </div>

        <div class="callout">
          <div class="callout-title">üí° Try This!</div>
          Move the <strong>Connectivity</strong> slider and watch how it affects the network structure below. 
          Higher connectivity means more edges between nodes ‚Äî notice how the mathematics adapts!
        </div>
      </div>
    </div>

    <div class="wide-container">
      <div class="graph-section">
        <h3 style="text-align: center; margin-bottom: var(--space-6);">üìä Your Network & Its Mathematical Fingerprint</h3>
        
        <div class="graph-container">
          <canvas id="graph-canvas"></canvas>
          <div class="graph-info">
            <div><strong>Connectivity:</strong> <span id="algebraic-connectivity">0.00</span></div>
            <div><strong>Robustness:</strong> <span id="spectral-gap">0.00</span></div>
            <div style="font-size: 0.75rem; margin-top: 0.5rem; opacity: 0.8;">
              üí° Higher = better
            </div>
          </div>
          <div class="graph-controls">
            <button class="graph-btn" id="edit-toggle">
              <i class="fas fa-edit"></i> Edit
            </button>
          </div>
        </div>

        <div class="chart-container">
          <div class="chart-title">üéµ Eigenvalue Spectrum - Your Network's "Musical Notes"</div>
          <div class="chart-canvas-container">
            <canvas id="eigenvalue-chart" width="600" height="150"></canvas>
          </div>
          <p style="text-align: center; margin-top: var(--space-3); font-size: 0.9rem; color: var(--text-muted);">
            Each bar represents an eigenvalue ‚Äî think of them as the natural "frequencies" your network can vibrate at
          </p>
        </div>

        <div class="insights-grid">
          <div class="insight-card">
            <div class="insight-value" id="lambda2-value">0.50</div>
            <div class="insight-label">üîë Œª‚ÇÇ (Connectivity)</div>
          </div>
          <div class="insight-card">
            <div class="insight-value" id="edge-count">0</div>
            <div class="insight-label">üîó Total Edges</div>
          </div>
          <div class="insight-card">
            <div class="insight-value" id="avg-degree">0.0</div>
            <div class="insight-label">üìä Avg Degree</div>
          </div>
          <div class="insight-card">
            <div class="insight-value" id="max-eigenvalue">0.0</div>
            <div class="insight-label">üìà Max Eigenvalue</div>
          </div>
        </div>
      </div>
    </div>

    <div class="blog-container">
      <h2 class="section-title">üé™ Try These Classic Examples</h2>
      
      <p>
        Different types of networks have completely different mathematical "fingerprints." 
        Let's explore some famous patterns that appear everywhere in nature and technology:
      </p>

      <div class="presets-grid">
        <div class="preset-btn" data-preset="path">
          <div class="preset-icon"><i class="fas fa-minus"></i></div>
          <div class="preset-name">Chain</div>
          <div class="preset-desc">Nodes in a line, like a supply chain</div>
        </div>
        <div class="preset-btn" data-preset="cycle">
          <div class="preset-icon"><i class="fas fa-circle-notch"></i></div>
          <div class="preset-name">Ring</div>
          <div class="preset-desc">Circular connections, like a token ring network</div>
        </div>
        <div class="preset-btn" data-preset="star">
          <div class="preset-icon"><i class="fas fa-star"></i></div>
          <div class="preset-name">Star</div>
          <div class="preset-desc">Central hub with spokes, like WiFi networks</div>
        </div>
        <div class="preset-btn" data-preset="complete">
          <div class="preset-icon"><i class="fas fa-project-diagram"></i></div>
          <div class="preset-name">Complete</div>
          <div class="preset-desc">Everyone connected to everyone</div>
        </div>
      </div>

      <div class="callout">
        <div class="callout-title">üîç What to Notice</div>
        Click each preset and watch how the eigenvalue spectrum changes! A <strong>Star</strong> network has 
        a very different mathematical fingerprint than a <strong>Ring</strong>. These patterns help algorithms 
        identify network types automatically.
      </div>

      <h2 class="section-title">‚úèÔ∏è Design Your Own Network</h2>
      
      <p>
        Want to experiment? Click the <strong>"Edit"</strong> button above the graph to manually add or remove 
        connections between nodes. This is where spectral graph theory gets really interesting ‚Äî you can see 
        how every change affects the mathematical properties instantly!
      </p>

      <div class="callout">
        <div class="callout-title">üß™ Experiment Ideas</div>
        <ul style="margin: var(--space-3) 0; padding-left: var(--space-6);">
          <li>Remove one edge from a ring ‚Äî watch Œª‚ÇÇ (connectivity) drop dramatically</li>
          <li>Add a "shortcut" edge across a long chain ‚Äî see the eigenvalues reorganize</li>
          <li>Create bottlenecks and watch how they affect network robustness</li>
          <li>Build your own community structure and observe the eigenvalue gaps</li>
        </ul>
      </div>

      <h2 class="section-title">üåä Information Flow Patterns</h2>
      
      <p>
        Now for the really cool part! Those eigenvalues aren't just abstract numbers ‚Äî they reveal how 
        information naturally "flows" through your network. Let's visualize these hidden vibration patterns:
      </p>

      <div class="interactive-section">
        <div class="vibration-controls">
          <label>Vibration pattern:</label>
          <select class="vibration-select" id="vibration-select">
            <option value="1">2nd Mode (Community Detection)</option>
            <option value="2">3rd Mode (Sub-communities)</option>
            <option value="3">4th Mode (Fine Structure)</option>
          </select>
          <button class="animate-btn" id="animate-vibration">
            <i class="fas fa-play"></i> Animate Flow
          </button>
        </div>

        <div class="callout">
          <div class="callout-title">üéµ Understanding the Colors</div>
          <ul style="margin: var(--space-3) 0; padding-left: var(--space-6);">
            <li><strong>üî¥ Red nodes:</strong> Information "peaks" here ‚Äî they're in one community</li>
            <li><strong>üîµ Blue nodes:</strong> Information "valleys" here ‚Äî they're in another community</li>
            <li><strong>‚ö™ White nodes:</strong> Neutral crossing points between communities</li>
          </ul>
          <p>This is how algorithms like spectral clustering automatically find communities in social networks!</p>
        </div>
      </div>

      <h2 class="section-title">üß† Why This Matters</h2>
      
      <p>
        You've just explored the mathematics that powers some of the most important algorithms in the modern world:
      </p>

      <div class="insights-grid">
        <div class="insight-card">
          <div style="font-size: 2rem; margin-bottom: var(--space-2);">üîç</div>
          <div class="insight-label"><strong>Google PageRank</strong><br>Uses the dominant eigenvector to rank web pages</div>
        </div>
        <div class="insight-card">
          <div style="font-size: 2rem; margin-bottom: var(--space-2);">üë•</div>
          <div class="insight-label"><strong>Social Networks</strong><br>Spectral clustering finds communities automatically</div>
        </div>
        <div class="insight-card">
          <div style="font-size: 2rem; margin-bottom: var(--space-2);">üß†</div>
          <div class="insight-label"><strong>Brain Research</strong><br>Maps neural connectivity and information flow</div>
        </div>
        <div class="insight-card">
          <div style="font-size: 2rem; margin-bottom: var(--space-2);">ü§ñ</div>
          <div class="insight-label"><strong>AI Systems</strong><br>Graph neural networks use spectral features</div>
        </div>
      </div>

      <h3 class="subsection-title">üéì The Mathematical Connection</h3>
      
      <p>
        Behind the scenes, we're working with something called the <strong>graph Laplacian matrix</strong>. 
        When you adjust the sliders above, you're actually controlling the eigenvalues of this matrix:
      </p>

      <ul style="margin: var(--space-4) 0; padding-left: var(--space-6);">
        <li><strong>Œª‚ÇÅ = 0:</strong> Always zero for connected graphs (fundamental theorem!)</li>
        <li><strong>Œª‚ÇÇ:</strong> The "algebraic connectivity" ‚Äî measures network robustness</li>
        <li><strong>Œª‚ÇÉ, Œª‚ÇÑ, ...:</strong> Reveal increasingly fine-grained community structure</li>
        <li><strong>Eigenvectors:</strong> Show natural partitions and information flow patterns</li>
      </ul>

      <div class="callout">
        <div class="callout-title">üéµ The Guitar String Analogy (Revisited)</div>
        Just like a guitar string has natural frequencies that create different musical notes, your network 
        has natural "eigenfrequencies" that create different information flow patterns. The eigenvalues are 
        the frequencies, and the eigenvectors are the vibration shapes!
      </div>

      <h2 class="section-title">üöÄ Keep Exploring!</h2>
      
      <p>
        You've just scratched the surface of spectral graph theory. This field connects pure mathematics 
        with practical applications in computer science, physics, biology, and social sciences. 
      </p>

      <p>
        The beautiful thing is that you don't need to master all the equations to understand the patterns. 
        By experimenting with the controls above, you're developing an intuitive understanding of how 
        network structure affects mathematical properties ‚Äî and vice versa.
      </p>

      <div class="callout">
        <div class="callout-title">üß™ Challenge Yourself</div>
        <ol style="margin: var(--space-3) 0; padding-left: var(--space-6);">
          <li>Can you create a network where Œª‚ÇÇ ‚âà 0? What does this mean?</li>
          <li>Try to maximize the spectral gap ‚Äî what kind of structure emerges?</li>
          <li>Use the vibration patterns to manually identify communities</li>
          <li>Compare eigenvalue "fingerprints" of different real-world network types</li>
          <li>Experiment with bottlenecks ‚Äî how do they affect information flow?</li>
        </ol>
      </div>

      <p style="text-align: center; margin: var(--space-16) 0; font-style: italic; color: var(--text-muted);">
        üåü <em>Remember: Every time you adjust those sliders, you're exploring the same mathematical principles 
        that help Google rank web pages, Facebook suggest friends, and neuroscientists understand the brain. 
        Pretty amazing, right?</em> üåü
      </p>
    </div>
  </main>

  <script>
    // Graph Laplacian Engine
    class GraphLaplacianEngine {
      constructor() {
        this.tolerance = 1e-10;
      }

      getPresetEigenvalues(type, n) {
        switch(type) {
          case 'path':
            return this.pathGraphEigenvalues(n);
          case 'cycle':
            return this.cycleGraphEigenvalues(n);
          case 'complete':
            return this.completeGraphEigenvalues(n);
          case 'star':
            return this.starGraphEigenvalues(n);
          default:
            return new Array(n).fill(0).map((_, i) => i * 0.8);
        }
      }

      pathGraphEigenvalues(n) {
        const eigenvals = [0];
        for (let k = 1; k < n; k++) {
          eigenvals.push(2 - 2 * Math.cos((k * Math.PI) / (n + 1)));
        }
        return eigenvals.sort((a, b) => a - b);
      }

      cycleGraphEigenvalues(n) {
        const eigenvals = [];
        for (let k = 0; k < n; k++) {
          eigenvals.push(2 - 2 * Math.cos((2 * Math.PI * k) / n));
        }
        return eigenvals.sort((a, b) => a - b);
      }

      completeGraphEigenvalues(n) {
        const eigenvals = [0];
        for (let i = 1; i < n; i++) {
          eigenvals.push(n);
        }
        return eigenvals;
      }

      starGraphEigenvalues(n) {
        const eigenvals = [0, 1];
        for (let i = 2; i < n; i++) {
          eigenvals.push(1);
        }
        eigenvals[n - 1] = n;
        return eigenvals.sort((a, b) => a - b);
      }

      propertiesToEigenvalues(connectivity, clustering, regularity, locality, symmetry, n) {
        const eigenvals = [0];
        
        const baseConnectivity = 0.05 + (connectivity / 100) * 4;
        eigenvals.push(baseConnectivity);
        
        for (let i = 2; i < n; i++) {
          const progress = (i - 1) / (n - 2);
          let baseValue = baseConnectivity * (1 + progress * 2);
          
          const clusteringGap = (clustering / 100) * Math.sin(progress * Math.PI) * 1.5;
          baseValue += clusteringGap;
          
          const regularityFactor = 1 + (regularity / 100) * 0.5;
          baseValue *= regularityFactor;
          
          const localityBoost = progress * (locality / 100) * 1.2;
          baseValue += localityBoost;
          
          if (symmetry > 50) {
            const symPattern = Math.cos(progress * Math.PI * 2) * (symmetry / 100) * 0.3;
            baseValue += symPattern;
          }
          
          baseValue = Math.max(eigenvals[i-1] + 0.05, baseValue);
          eigenvals.push(baseValue);
        }
        
        return eigenvals;
      }

      generateGraphFromEigenvalues(eigenvals) {
        const n = eigenvals.length;
        const positions = this.generatePositions(eigenvals);
        const adjacency = this.generateAdjacency(eigenvals);
        
        return {
          positions,
          adjacency,
          eigenvalues: eigenvals,
          properties: this.computeGraphProperties(eigenvals, adjacency)
        };
      }

      generatePositions(eigenvals) {
        const n = eigenvals.length;
        const positions = [];
        
        for (let i = 0; i < n; i++) {
          const angle = (2 * Math.PI * i) / n;
          const eigenInfluence = eigenvals[Math.min(i + 1, eigenvals.length - 1)] || 1;
          const radius = 120 + 40 * Math.log(1 + eigenInfluence);
          
          positions.push({
            x: 350 + radius * Math.cos(angle),
            y: 250 + radius * Math.sin(angle)
          });
        }
        
        return positions;
      }

      generateAdjacency(eigenvals) {
        const n = eigenvals.length;
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        
        const connectivity = eigenvals[1] || 0.5;
        const threshold = 0.2 + connectivity * 0.4;
        
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            const distance = Math.abs(i - j);
            const normalizedDistance = Math.min(distance, n - distance) / n;
            const probability = Math.exp(-normalizedDistance / threshold);
            
            if (probability > 0.3 + Math.random() * 0.3) {
              adjacency[i][j] = adjacency[j][i] = 1;
            }
          }
        }
        
        for (let i = 0; i < n - 1; i++) {
          if (Math.random() > 0.7) {
            adjacency[i][i + 1] = adjacency[i + 1][i] = 1;
          }
        }
        
        return adjacency;
      }

      computeGraphProperties(eigenvals, adjacency) {
        const n = eigenvals.length;
        
        let edgeCount = 0;
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            if (adjacency[i][j]) edgeCount++;
          }
        }
        
        return {
          spectralGap: eigenvals[1] - eigenvals[0],
          algebraicConnectivity: eigenvals[1],
          maxEigenvalue: eigenvals[n - 1],
          edgeCount,
          avgDegree: (2 * edgeCount) / n
        };
      }

      generateEigenvector(eigenvals, mode) {
        const n = eigenvals.length;
        const eigenvector = [];
        
        switch(mode) {
          case 1:
            for (let i = 0; i < n; i++) {
              eigenvector.push(Math.cos(2 * Math.PI * i / n));
            }
            break;
          case 2:
            for (let i = 0; i < n; i++) {
              eigenvector.push(Math.cos(4 * Math.PI * i / n) * Math.exp(-i * 0.1));
            }
            break;
          case 3:
            for (let i = 0; i < n; i++) {
              eigenvector.push(Math.sin(6 * Math.PI * i / n) * Math.cos(2 * Math.PI * i / n));
            }
            break;
          default:
            for (let i = 0; i < n; i++) {
              eigenvector.push(Math.cos((mode + 1) * 2 * Math.PI * i / n));
            }
        }
        
        const maxAbs = Math.max(...eigenvector.map(Math.abs), 0.001);
        return eigenvector.map(v => v / maxAbs);
      }
    }

    // Graph Visualizer
    class GraphVisualizer {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.setupCanvas();
        this.graph = null;
        this.eigenvectorColors = null;
        this.isAnimating = false;
        this.editMode = false;
        this.selectedNode = null;
        
        this.nodeRadius = 20;
        this.nodeColor = '#6366f1';
        this.edgeColor = '#cbd5e1';
        this.edgeWidth = 3;
        
        this.setupInteraction();
      }

      setupCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
      }

      setupInteraction() {
        let isDragging = false;
        let dragNode = null;
        
        this.canvas.addEventListener('mousedown', (e) => {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          if (this.graph) {
            const nodeIndex = this.getNodeAt(x, y);
            if (nodeIndex !== -1) {
              if (this.editMode) {
                this.handleNodeClickForEditing(nodeIndex);
              } else {
                isDragging = true;
                dragNode = nodeIndex;
                this.canvas.style.cursor = 'grabbing';
              }
            }
          }
        });
        
        this.canvas.addEventListener('mousemove', (e) => {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          if (isDragging && dragNode !== null && this.graph) {
            this.graph.positions[dragNode] = { x, y };
            this.render();
          } else if (this.graph) {
            const nodeIndex = this.getNodeAt(x, y);
            this.canvas.style.cursor = nodeIndex !== -1 ? 'grab' : 'default';
          }
        });
        
        this.canvas.addEventListener('mouseup', () => {
          isDragging = false;
          dragNode = null;
          this.canvas.style.cursor = 'default';
        });
      }

      handleNodeClickForEditing(nodeIndex) {
        if (this.selectedNode === null) {
          this.selectedNode = nodeIndex;
        } else if (this.selectedNode !== nodeIndex) {
          this.toggleEdge(this.selectedNode, nodeIndex);
          this.selectedNode = null;
        } else {
          this.selectedNode = null;
        }
        this.render();
      }

      toggleEdge(i, j) {
        if (i === j) return;
        
        this.graph.adjacency[i][j] = this.graph.adjacency[i][j] ? 0 : 1;
        this.graph.adjacency[j][i] = this.graph.adjacency[i][j];
        
        if (window.spectralApp) {
          window.spectralApp.onGraphEdited();
        }
      }

      getNodeAt(x, y) {
        if (!this.graph) return -1;
        
        for (let i = 0; i < this.graph.positions.length; i++) {
          const pos = this.graph.positions[i];
          const dx = x - pos.x;
          const dy = y - pos.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= this.nodeRadius + 5) {
            return i;
          }
        }
        
        return -1;
      }

      setEditMode(enabled) {
        this.editMode = enabled;
        this.selectedNode = null;
        this.canvas.style.cursor = enabled ? 'crosshair' : 'default';
        this.render();
      }

      setGraph(graph) {
        this.graph = graph;
        this.render();
      }

      setEigenvectorColors(colors) {
        this.eigenvectorColors = colors;
        this.render();
      }

      clearEigenvectorColors() {
        this.eigenvectorColors = null;
        this.render();
      }

      animateVibration(colors, duration = 3000) {
        if (this.isAnimating) return;
        
        this.isAnimating = true;
        const startTime = Date.now();
        
        const animate = () => {
          const elapsed = Date.now() - startTime;
          const progress = (elapsed % duration) / duration;
          const phase = Math.sin(progress * Math.PI * 2);
          
          const animatedColors = colors.map(color => color * phase);
          this.setEigenvectorColors(animatedColors);
          
          if (this.isAnimating) {
            requestAnimationFrame(animate);
          }
        };
        
        animate();
      }

      stopAnimation() {
        this.isAnimating = false;
      }

      render() {
        if (!this.graph) return;

        const ctx = this.ctx;
        const rect = this.canvas.getBoundingClientRect();
        
        ctx.clearRect(0, 0, rect.width, rect.height);
        
        this.drawEdges();
        this.drawNodes();
        this.drawLabels();
        
        if (this.editMode && this.selectedNode !== null) {
          this.drawPotentialEdges();
        }
      }

      drawEdges() {
        const ctx = this.ctx;
        const { positions, adjacency } = this.graph;
        
        ctx.strokeStyle = this.edgeColor;
        ctx.lineWidth = this.edgeWidth;
        ctx.lineCap = 'round';
        
        for (let i = 0; i < positions.length; i++) {
          for (let j = i + 1; j < positions.length; j++) {
            if (adjacency[i][j]) {
              ctx.beginPath();
              ctx.moveTo(positions[i].x, positions[i].y);
              ctx.lineTo(positions[j].x, positions[j].y);
              ctx.stroke();
            }
          }
        }
      }

      drawNodes() {
        const ctx = this.ctx;
        const { positions } = this.graph;
        
        positions.forEach((pos, i) => {
          let fillColor = this.nodeColor;
          let strokeColor = '#ffffff';
          let strokeWidth = 3;
          
          if (this.eigenvectorColors && this.eigenvectorColors[i] !== undefined) {
            const value = this.eigenvectorColors[i];
            const intensity = Math.abs(value);
            if (value > 0) {
              fillColor = `rgba(239, 68, 68, ${0.4 + 0.6 * intensity})`;
            } else {
              fillColor = `rgba(59, 130, 246, ${0.4 + 0.6 * intensity})`;
            }
          }
          
          if (this.editMode && this.selectedNode === i) {
            strokeColor = '#10b981';
            strokeWidth = 5;
          }
          
          // Shadow
          ctx.beginPath();
          ctx.arc(pos.x + 2, pos.y + 2, this.nodeRadius, 0, 2 * Math.PI);
          ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
          ctx.fill();
          
          // Node body
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, this.nodeRadius, 0, 2 * Math.PI);
          ctx.fillStyle = fillColor;
          ctx.fill();
          
          // Border
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = strokeWidth;
          ctx.stroke();
        });
      }

      drawLabels() {
        const ctx = this.ctx;
        const { positions } = this.graph;
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 14px Inter';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        ctx.shadowBlur = 2;
        
        positions.forEach((pos, i) => {
          ctx.fillText(i.toString(), pos.x, pos.y);
        });
        
        ctx.shadowColor = 'transparent';
      }

      drawPotentialEdges() {
        if (this.selectedNode === null) return;
        
        const ctx = this.ctx;
        const selectedPos = this.graph.positions[this.selectedNode];
        
        this.graph.positions.forEach((pos, i) => {
          if (i !== this.selectedNode && !this.graph.adjacency[this.selectedNode][i]) {
            ctx.beginPath();
            ctx.moveTo(selectedPos.x, selectedPos.y);
            ctx.lineTo(pos.x, pos.y);
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.globalAlpha = 0.5;
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.globalAlpha = 1;
          }
        });
      }

      updateProperties(properties) {
        document.getElementById('algebraic-connectivity').textContent = 
          properties.algebraicConnectivity.toFixed(3);
        document.getElementById('spectral-gap').textContent = 
          properties.spectralGap.toFixed(3);
        document.getElementById('lambda2-value').textContent = 
          properties.algebraicConnectivity.toFixed(2);
        document.getElementById('edge-count').textContent = 
          properties.edgeCount.toString();
        document.getElementById('avg-degree').textContent = 
          properties.avgDegree.toFixed(1);
        document.getElementById('max-eigenvalue').textContent = 
          properties.maxEigenvalue.toFixed(1);
      }
    }

    // Eigenvalue Chart
    class EigenvalueChart {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.eigenvalues = [];
        this.setupCanvas();
      }

      setupCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
      }

      updateEigenvalues(eigenvalues) {
        this.eigenvalues = eigenvalues;
        this.render();
      }

      render() {
        if (!this.eigenvalues.length) return;

        const ctx = this.ctx;
        const rect = this.canvas.getBoundingClientRect();
        const padding = 30;
        const chartWidth = rect.width - 2 * padding;
        const chartHeight = rect.height - 2 * padding;
        
        ctx.clearRect(0, 0, rect.width, rect.height);
        
        const barWidth = chartWidth / this.eigenvalues.length;
        const maxValue = Math.max(...this.eigenvalues, 1);
        
        this.eigenvalues.forEach((value, i) => {
          const barHeight = (value / maxValue) * chartHeight;
          const x = padding + i * barWidth;
          const y = rect.height - padding - barHeight;
          
          const gradient = ctx.createLinearGradient(0, y, 0, y + barHeight);
          if (i === 0) {
            gradient.addColorStop(0, '#10b981');
            gradient.addColorStop(1, '#059669');
          } else if (i === 1) {
            gradient.addColorStop(0, '#6366f1');
            gradient.addColorStop(1, '#4f46e5');
          } else {
            gradient.addColorStop(0, '#ec4899');
            gradient.addColorStop(1, '#db2777');
          }
          
          ctx.fillStyle = gradient;
          ctx.fillRect(x + 3, y, barWidth - 6, barHeight);
          
          // Labels
          ctx.fillStyle = '#64748b';
          ctx.font = '10px Inter';
          ctx.textAlign = 'center';
          ctx.fillText(value.toFixed(2), x + barWidth / 2, y - 8);
          ctx.fillText(`Œª${i + 1}`, x + barWidth / 2, rect.height - 8);
        });
      }
    }

    // Main Application
    class SpectralGraphApp {
      constructor() {
        this.engine = new GraphLaplacianEngine();
        this.visualizer = null;
        this.chart = null;
        this.currentGraph = null;
        this.nodeCount = 5;
        
        this.init();
      }

      init() {
        const canvas = document.getElementById('graph-canvas');
        if (canvas) {
          this.visualizer = new GraphVisualizer(canvas);
        }

        const chartCanvas = document.getElementById('eigenvalue-chart');
        if (chartCanvas) {
          this.chart = new EigenvalueChart(chartCanvas);
        }

        this.setupControls();
        this.updateGraph();

        window.addEventListener('resize', () => {
          if (this.visualizer) {
            this.visualizer.setupCanvas();
            this.visualizer.render();
          }
          if (this.chart) {
            this.chart.setupCanvas();
            this.chart.render();
          }
        });

        window.spectralApp = this;
      }

      setupControls() {
        // Property sliders
        const sliders = [
          'connectivity-slider', 
          'clustering-slider', 
          'regularity-slider', 
          'locality-slider', 
          'symmetry-slider'
        ];
        
        sliders.forEach(sliderId => {
          const slider = document.getElementById(sliderId);
          if (slider) {
            slider.addEventListener('input', () => {
              this.updatePropertyValue(sliderId);
              this.updateGraph();
            });
            this.updatePropertyValue(sliderId);
          }
        });

        // Node count
        const nodeCountSelect = document.getElementById('node-count');
        if (nodeCountSelect) {
          nodeCountSelect.addEventListener('change', (e) => {
            this.nodeCount = parseInt(e.target.value);
            this.updateGraph();
          });
        }

        // Presets
        const presetButtons = document.querySelectorAll('.preset-btn');
        presetButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            presetButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            setTimeout(() => btn.classList.remove('active'), 1000);
            
            const preset = btn.dataset.preset;
            this.loadPreset(preset);
          });
        });

        // Edit mode
        const editToggle = document.getElementById('edit-toggle');
        if (editToggle) {
          editToggle.addEventListener('click', () => {
            const isActive = editToggle.classList.toggle('active');
            editToggle.innerHTML = isActive ? 
              '<i class="fas fa-times"></i> Exit' : 
              '<i class="fas fa-edit"></i> Edit';
            
            if (this.visualizer) {
              this.visualizer.setEditMode(isActive);
            }
          });
        }

        // Vibration controls
        const vibrationSelect = document.getElementById('vibration-select');
        const animateBtn = document.getElementById('animate-vibration');
        
        if (vibrationSelect) {
          vibrationSelect.addEventListener('change', () => {
            this.showVibrationVisualization();
          });
        }
        
        if (animateBtn) {
          animateBtn.addEventListener('click', () => {
            const isPlaying = animateBtn.classList.toggle('playing');
            
            if (isPlaying) {
              animateBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Flow';
              this.startVibrationAnimation();
            } else {
              animateBtn.innerHTML = '<i class="fas fa-play"></i> Animate Flow';
              this.stopVibrationAnimation();
            }
          });
        }
      }

      updatePropertyValue(sliderId) {
        const slider = document.getElementById(sliderId);
        const value = parseInt(slider.value);
        
        const valueMap = {
          'connectivity-slider': {
            id: 'connectivity-value',
            values: ['Very sparse', 'Sparse', 'Moderate', 'Well connected', 'Highly connected']
          },
          'clustering-slider': {
            id: 'clustering-value', 
            values: ['Uniform', 'Some clusters', 'Moderate clustering', 'Strong clusters', 'Highly clustered']
          },
          'regularity-slider': {
            id: 'regularity-value',
            values: ['Star-like hubs', 'Some hubs', 'Balanced', 'Regular', 'Very uniform']
          },
          'locality-slider': {
            id: 'locality-value',
            values: ['Long-range', 'Mixed range', 'Moderate local', 'Mostly local', 'Highly local']
          },
          'symmetry-slider': {
            id: 'symmetry-value',
            values: ['Random', 'Somewhat random', 'Balanced', 'Organized', 'Highly symmetric']
          }
        };
        
        const config = valueMap[sliderId];
        if (config) {
          const index = Math.floor((value / 100) * (config.values.length - 1));
          const valueElement = document.getElementById(config.id);
          if (valueElement) {
            valueElement.textContent = config.values[index];
          }
        }
      }

      loadPreset(preset) {
        const eigenvalues = this.engine.getPresetEigenvalues(preset, this.nodeCount);
        
        const presetConfigs = {
          'path': [30, 20, 70, 85, 70],
          'cycle': [40, 30, 80, 60, 90],
          'star': [60, 80, 10, 40, 50],
          'complete': [100, 10, 90, 20, 95]
        };
        
        if (presetConfigs[preset]) {
          this.setSliderValues(...presetConfigs[preset]);
        }
        
        this.updateGraphFromEigenvalues(eigenvalues);
      }

      setSliderValues(connectivity, clustering, regularity, locality, symmetry) {
        const sliders = [
          'connectivity-slider', 
          'clustering-slider', 
          'regularity-slider', 
          'locality-slider', 
          'symmetry-slider'
        ];
        const values = [connectivity, clustering, regularity, locality, symmetry];
        
        sliders.forEach((id, index) => {
          const slider = document.getElementById(id);
          if (slider) {
            slider.value = values[index];
            this.updatePropertyValue(id);
          }
        });
      }

      updateGraph() {
        const connectivity = parseInt(document.getElementById('connectivity-slider').value);
        const clustering = parseInt(document.getElementById('clustering-slider').value);
        const regularity = parseInt(document.getElementById('regularity-slider').value);
        const locality = parseInt(document.getElementById('locality-slider').value);
        const symmetry = parseInt(document.getElementById('symmetry-slider').value);
        
        const eigenvalues = this.engine.propertiesToEigenvalues(
          connectivity, clustering, regularity, locality, symmetry, this.nodeCount
        );
        
        this.updateGraphFromEigenvalues(eigenvalues);
      }

      updateGraphFromEigenvalues(eigenvalues) {
        const graph = this.engine.generateGraphFromEigenvalues(eigenvalues);
        this.currentGraph = graph;
        
        if (this.visualizer) {
          this.visualizer.setGraph(graph);
          this.visualizer.updateProperties(graph.properties);
        }
        
        if (this.chart) {
          this.chart.updateEigenvalues(graph.eigenvalues);
        }
      }

      onGraphEdited() {
        if (this.currentGraph) {
          const newProperties = this.engine.computeGraphProperties(
            this.currentGraph.eigenvalues, 
            this.currentGraph.adjacency
          );
          this.currentGraph.properties = newProperties;
          
          if (this.visualizer) {
            this.visualizer.updateProperties(newProperties);
          }
        }
      }

      showVibrationVisualization() {
        if (!this.currentGraph || !this.visualizer) return;
        
        const modeSelect = document.getElementById('vibration-select');
        const mode = parseInt(modeSelect.value);
        
        const eigenvector = this.engine.generateEigenvector(this.currentGraph.eigenvalues, mode);
        this.visualizer.setEigenvectorColors(eigenvector);
      }

      startVibrationAnimation() {
        if (!this.currentGraph || !this.visualizer) return;
        
        const modeSelect = document.getElementById('vibration-select');
        const mode = parseInt(modeSelect.value);
        
        const eigenvector = this.engine.generateEigenvector(this.currentGraph.eigenvalues, mode);
        this.visualizer.animateVibration(eigenvector, 3000);
      }

      stopVibrationAnimation() {
        if (this.visualizer) {
          this.visualizer.stopAnimation();
        }
        
        const animateBtn = document.getElementById('animate-vibration');
        if (animateBtn) {
          animateBtn.classList.remove('playing');
          animateBtn.innerHTML = '<i class="fas fa-play"></i> Animate Flow';
        }
      }
    }

    // Initialize the application
    document.addEventListener('DOMContentLoaded', () => {
      new SpectralGraphApp();
    });
  </script>
</body>
</html>