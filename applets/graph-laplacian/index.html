<!-- graph-laplacian.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Interactive guide to spectral graph theory - understand eigenvalues and eigenvectors through visual exploration">
  <title>Understanding Spectral Graph Theory — Jack Kinney</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <!-- KaTeX for math rendering -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
  
  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --secondary: #ec4899;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-tertiary: #e2e8f0;
      --text-primary: #0f172a;
      --text-secondary: #475569;
      --text-muted: #64748b;
      --border: #e2e8f0;
      --font-sans: 'Inter', system-ui, sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-sans);
      line-height: 1.6;
      color: var(--text-primary);
      background: var(--bg-primary);
    }

    /* Header */
    .header {
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border);
      padding: 1rem 0;
      position: sticky;
      top: 0;
      z-index: 100;
      backdrop-filter: blur(10px);
    }

    .header-content {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--text-primary);
      font-family: var(--font-mono);
      text-decoration: none;
    }

    .back-link {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--primary);
      text-decoration: none;
      font-weight: 500;
    }

    /* Main Layout */
    .main-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
    }

    .intro-section {
      max-width: 800px;
      margin: 0 auto 3rem;
      text-align: center;
    }

    .page-title {
      font-size: 2.5rem;
      font-weight: 800;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .subtitle {
      font-size: 1.25rem;
      color: var(--text-secondary);
      margin-bottom: 2rem;
    }

    /* Interactive Section */
    .interactive-container {
      display: grid;
      grid-template-columns: 400px 1fr;
      gap: 2rem;
      margin-bottom: 3rem;
    }

    .controls-panel {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      height: fit-content;
      position: sticky;
      top: 80px;
      max-height: calc(100vh - 100px);
      overflow-y: auto;
    }

    .visualization-panel {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      border-bottom: 1px solid var(--border);
    }

    .tab {
      padding: 0.5rem 1rem;
      background: none;
      border: none;
      cursor: pointer;
      font-weight: 500;
      color: var(--text-muted);
      position: relative;
      transition: color 0.3s;
    }

    .tab.active {
      color: var(--primary);
    }

    .tab::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--primary);
      transform: scaleX(0);
      transition: transform 0.3s;
    }

    .tab.active::after {
      transform: scaleX(1);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Graph Canvas */
    .graph-container {
      position: relative;
      background: white;
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 1.5rem;
      overflow: hidden;
    }

    #graph-canvas {
      width: 100%;
      height: 400px;
      cursor: grab;
    }

    #graph-canvas.dragging {
      cursor: grabbing;
    }

    #graph-canvas.edit-mode {
      cursor: crosshair;
    }

    .graph-toolbar {
      position: absolute;
      top: 1rem;
      left: 1rem;
      display: flex;
      gap: 0.5rem;
    }

    .toolbar-btn {
      background: white;
      border: 1px solid var(--border);
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: all 0.2s;
    }

    .toolbar-btn:hover {
      background: var(--bg-secondary);
      border-color: var(--primary);
    }

    .toolbar-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    /* Eigenvalue Controls */
    .eigenvalue-list {
      margin-bottom: 1.5rem;
    }

    .eigenvalue-item {
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: white;
      border: 1px solid var(--border);
      border-radius: 8px;
    }

    .eigenvalue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .eigenvalue-label {
      font-weight: 600;
      font-family: var(--font-mono);
    }

    .eigenvalue-value {
      color: var(--primary);
      font-weight: 600;
      font-family: var(--font-mono);
    }

    .eigenvalue-slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--bg-tertiary);
      outline: none;
      -webkit-appearance: none;
      margin-bottom: 0.5rem;
    }

    .eigenvalue-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .eigenvalue-slider:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .eigenvalue-info {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    /* Eigenvector Display */
    .eigenvector-display {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
    }

    .eigenvector-card {
      background: white;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .eigenvector-card:hover {
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    .eigenvector-card.active {
      border-color: var(--primary);
      background: var(--bg-secondary);
    }

    .eigenvector-header {
      font-weight: 600;
      margin-bottom: 0.5rem;
      font-family: var(--font-mono);
    }

    .eigenvector-preview {
      display: flex;
      gap: 0.25rem;
      margin-bottom: 0.5rem;
    }

    .node-value {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid var(--border);
    }

    .eigenvector-description {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    /* Properties Display */
    .properties-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .property-card {
      background: white;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      text-align: center;
    }

    .property-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--primary);
      margin-bottom: 0.25rem;
    }

    .property-label {
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    /* Presets */
    .presets-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }

    .preset-btn {
      background: white;
      border: 1px solid var(--border);
      padding: 0.75rem;
      border-radius: 8px;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s;
    }

    .preset-btn:hover {
      border-color: var(--primary);
      background: var(--bg-secondary);
    }

    .preset-name {
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .preset-desc {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    /* Educational Sections */
    .education-section {
      max-width: 800px;
      margin: 0 auto;
    }

    .concept-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 2rem;
      margin-bottom: 2rem;
    }

    .concept-title {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 1rem;
      color: var(--primary);
    }

    .math-block {
      background: white;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
      overflow-x: auto;
    }

    .intuition-box {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(236, 72, 153, 0.1));
      border-left: 4px solid var(--primary);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 8px 8px 0;
    }

    .example-box {
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .interactive-container {
        grid-template-columns: 1fr;
      }
      
      .controls-panel {
        position: static;
        max-height: none;
      }
    }

    /* Loading */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--border);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="header-content">
      <a href="./index.html" class="logo">&lt;JTK/&gt;</a>
      <a href="./projects.html" class="back-link">
        <i class="fas fa-arrow-left"></i>
        Back to Projects
      </a>
    </div>
  </header>

  <main>
    <div class="main-container">
      <div class="intro-section">
        <h1 class="page-title">Understanding Spectral Graph Theory</h1>
        <p class="subtitle">
          Discover how the structure of networks is encoded in eigenvalues and eigenvectors. 
          Build intuition through interactive exploration!
        </p>
      </div>

      <div class="interactive-container">
        <div class="controls-panel">
          <div class="tabs">
            <button class="tab active" data-tab="build">Build Graph</button>
            <button class="tab" data-tab="eigenvalues">Eigenvalues</button>
            <button class="tab" data-tab="eigenvectors">Eigenvectors</button>
          </div>

          <div class="tab-content active" id="build-tab">
            <h3 style="margin-bottom: 1rem;">Quick Start</h3>
            <div class="presets-grid">
              <button class="preset-btn" data-preset="path">
                <div class="preset-name">Path</div>
                <div class="preset-desc">Simple chain</div>
              </button>
              <button class="preset-btn" data-preset="cycle">
                <div class="preset-name">Cycle</div>
                <div class="preset-desc">Circular graph</div>
              </button>
              <button class="preset-btn" data-preset="complete">
                <div class="preset-name">Complete</div>
                <div class="preset-desc">All connected</div>
              </button>
              <button class="preset-btn" data-preset="star">
                <div class="preset-name">Star</div>
                <div class="preset-desc">Central hub</div>
              </button>
              <button class="preset-btn" data-preset="barbell">
                <div class="preset-name">Barbell</div>
                <div class="preset-desc">Two clusters</div>
              </button>
              <button class="preset-btn" data-preset="tree">
                <div class="preset-name">Tree</div>
                <div class="preset-desc">No cycles</div>
              </button>
            </div>

            <div style="margin-top: 1.5rem;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Number of Nodes</label>
              <select id="node-count" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 6px;">
                <option value="3">3 nodes</option>
                <option value="4">4 nodes</option>
                <option value="5" selected>5 nodes</option>
                <option value="6">6 nodes</option>
                <option value="7">7 nodes</option>
                <option value="8">8 nodes</option>
              </select>
            </div>

            <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
              <p style="font-size: 0.875rem; margin-bottom: 0.5rem;">
                <strong>💡 Tip:</strong> Click "Edit Graph" above to manually add or remove edges by clicking on nodes!
              </p>
            </div>
          </div>

          <div class="tab-content" id="eigenvalues-tab">
            <h3 style="margin-bottom: 1rem;">Graph Eigenvalues</h3>
            <div id="eigenvalue-list" class="eigenvalue-list">
              <!-- Eigenvalues will be dynamically inserted here -->
            </div>
            <div style="margin-top: 1rem; padding: 1rem; background: rgba(99, 102, 241, 0.1); border-radius: 8px;">
              <p style="font-size: 0.875rem;">
                <strong>Note:</strong> λ₁ is always 0 for connected graphs. This represents the constant eigenvector.
              </p>
            </div>
          </div>

          <div class="tab-content" id="eigenvectors-tab">
            <h3 style="margin-bottom: 1rem;">Eigenvector Visualization</h3>
            <div id="eigenvector-display" class="eigenvector-display">
              <!-- Eigenvector cards will be dynamically inserted here -->
            </div>
          </div>
        </div>

        <div class="visualization-panel">
          <div class="graph-container">
            <canvas id="graph-canvas"></canvas>
            <div class="graph-toolbar">
              <button class="toolbar-btn" id="edit-btn">
                <i class="fas fa-edit"></i>
                Edit Graph
              </button>
              <button class="toolbar-btn" id="reset-btn">
                <i class="fas fa-undo"></i>
                Reset View
              </button>
            </div>
          </div>

          <div class="properties-grid">
            <div class="property-card">
              <div class="property-value" id="num-edges">0</div>
              <div class="property-label">Edges</div>
            </div>
            <div class="property-card">
              <div class="property-value" id="connectivity">0.00</div>
              <div class="property-label">Connectivity (λ₂)</div>
            </div>
            <div class="property-card">
              <div class="property-value" id="spectral-gap">0.00</div>
              <div class="property-label">Spectral Gap</div>
            </div>
            <div class="property-card">
              <div class="property-value" id="max-eigenvalue">0.00</div>
              <div class="property-label">Max Eigenvalue</div>
            </div>
          </div>
        </div>
      </div>

      <div class="education-section">
        <div class="concept-card">
          <h2 class="concept-title">What is the Graph Laplacian?</h2>
          <p>
            The graph Laplacian is a matrix that encodes the structure of a graph. For a graph with n nodes:
          </p>
          <div class="math-block">
            <div class="katex-eq">L = D - A</div>
          </div>
          <p>Where:</p>
          <ul style="margin-left: 2rem;">
            <li><strong>D</strong> is the degree matrix (diagonal matrix with node degrees)</li>
            <li><strong>A</strong> is the adjacency matrix (1 if nodes are connected, 0 otherwise)</li>
          </ul>
          
          <div class="intuition-box">
            <strong>Intuition:</strong> The Laplacian measures how much each node differs from its neighbors. It's like a "difference operator" for graphs!
          </div>
        </div>

        <div class="concept-card">
          <h2 class="concept-title">Understanding Eigenvalues</h2>
          <p>
            The eigenvalues of the Laplacian reveal fundamental properties of your graph:
          </p>
          
          <div class="example-box">
            <strong>λ₁ = 0:</strong> Always zero for connected graphs. The corresponding eigenvector is constant (all nodes have the same value).
          </div>
          
          <div class="example-box">
            <strong>λ₂ (Algebraic Connectivity):</strong> Measures how well-connected the graph is. Higher values mean better connectivity. If λ₂ = 0, the graph is disconnected!
          </div>
          
          <div class="example-box">
            <strong>λₙ (Largest Eigenvalue):</strong> Related to the graph's expansion properties. Complete graphs have λₙ = n.
          </div>
        </div>

        <div class="concept-card">
          <h2 class="concept-title">Understanding Eigenvectors</h2>
          <p>
            Eigenvectors show patterns of variation across the graph. They answer: "How can values spread across nodes?"
          </p>
          
          <div class="intuition-box">
            <strong>Physical Analogy:</strong> Imagine the graph as a network of springs. Eigenvectors show the natural vibration modes, and eigenvalues give the frequencies!
          </div>
          
          <p style="margin-top: 1rem;">
            The second eigenvector (Fiedler vector) is particularly special - it naturally partitions the graph into communities!
          </p>
        </div>

        <div class="concept-card">
          <h2 class="concept-title">Try These Experiments</h2>
          <ol style="margin-left: 2rem; line-height: 2;">
            <li><strong>Build a path graph:</strong> Notice how eigenvalues increase gradually</li>
            <li><strong>Close the path into a cycle:</strong> See how the spectrum changes</li>
            <li><strong>Create a bottleneck:</strong> Remove edges to barely keep the graph connected - watch λ₂ drop!</li>
            <li><strong>Visualize the Fiedler vector:</strong> It naturally finds graph cuts</li>
            <li><strong>Compare star vs complete:</strong> Drastically different spectra for different structures</li>
          </ol>
        </div>
      </div>
    </div>
  </main>

  <script>
    // Initialize KaTeX rendering
    document.addEventListener("DOMContentLoaded", function() {
      const mathElements = document.querySelectorAll('.katex-eq');
      mathElements.forEach(el => {
        katex.render(el.textContent, el, { displayMode: true });
      });
    });

    // Graph Theory Engine
    class SpectralGraphEngine {
      constructor() {
        this.tolerance = 1e-10;
      }

      // Compute Laplacian matrix
      computeLaplacian(adjacency) {
        const n = adjacency.length;
        const laplacian = Array(n).fill().map(() => Array(n).fill(0));
        
        for (let i = 0; i < n; i++) {
          let degree = 0;
          for (let j = 0; j < n; j++) {
            if (adjacency[i][j]) {
              degree++;
              laplacian[i][j] = -1;
            }
          }
          laplacian[i][i] = degree;
        }
        
        return laplacian;
      }

      // Compute eigenvalues and eigenvectors using power iteration
      computeEigendecomposition(laplacian) {
        const n = laplacian.length;
        
        // For small matrices, use a simplified approach
        // In production, you'd use a proper numerical library
        const eigendata = this.approximateEigen(laplacian);
        
        return eigendata;
      }

      // Simplified eigenvalue computation for demonstration
      approximateEigen(matrix) {
        const n = matrix.length;
        const eigenvalues = [];
        const eigenvectors = [];
        
        // For demonstration, we'll compute approximate values
        // Real implementation would use Jacobi or QR algorithm
        
        // First eigenvalue is always 0 for Laplacian
        eigenvalues.push(0);
        eigenvectors.push(Array(n).fill(1/Math.sqrt(n)));
        
        // Approximate other eigenvalues based on graph structure
        // This is simplified - real computation would be iterative
        const trace = matrix.reduce((sum, row, i) => sum + row[i], 0);
        
        for (let k = 1; k < n; k++) {
          // Approximate eigenvalues
          const approxEigenvalue = (trace / n) * (1 + Math.sin(k * Math.PI / n));
          eigenvalues.push(approxEigenvalue);
          
          // Generate orthogonal eigenvectors
          const vec = Array(n).fill(0).map((_, i) => 
            Math.sin((k * Math.PI * (i + 1)) / (n + 1))
          );
          const norm = Math.sqrt(vec.reduce((sum, v) => sum + v * v, 0));
          eigenvectors.push(vec.map(v => v / norm));
        }
        
        return { eigenvalues, eigenvectors };
      }

      // Generate preset graphs
      generatePreset(type, n) {
        const adjacency = Array(n).fill().map(() => Array(n).fill(0));
        
        switch(type) {
          case 'path':
            for (let i = 0; i < n - 1; i++) {
              adjacency[i][i + 1] = adjacency[i + 1][i] = 1;
            }
            break;
            
          case 'cycle':
            for (let i = 0; i < n; i++) {
              adjacency[i][(i + 1) % n] = adjacency[(i + 1) % n][i] = 1;
            }
            break;
            
          case 'complete':
            for (let i = 0; i < n; i++) {
              for (let j = i + 1; j < n; j++) {
                adjacency[i][j] = adjacency[j][i] = 1;
              }
            }
            break;
            
          case 'star':
            for (let i = 1; i < n; i++) {
              adjacency[0][i] = adjacency[i][0] = 1;
            }
            break;
            
          case 'barbell':
            const half = Math.floor(n / 2);
            // First clique
            for (let i = 0; i < half; i++) {
              for (let j = i + 1; j < half; j++) {
                adjacency[i][j] = adjacency[j][i] = 1;
              }
            }
            // Second clique
            for (let i = half; i < n; i++) {
              for (let j = i + 1; j < n; j++) {
                adjacency[i][j] = adjacency[j][i] = 1;
              }
            }
            // Connect cliques
            if (half > 0 && half < n) {
              adjacency[half - 1][half] = adjacency[half][half - 1] = 1;
            }
            break;
            
          case 'tree':
            // Binary tree structure
            for (let i = 0; i < n; i++) {
              const left = 2 * i + 1;
              const right = 2 * i + 2;
              if (left < n) {
                adjacency[i][left] = adjacency[left][i] = 1;
              }
              if (right < n) {
                adjacency[i][right] = adjacency[right][i] = 1;
              }
            }
            break;
        }
        
        return adjacency;
      }

      // Check if graph is connected using DFS
      isConnected(adjacency) {
        const n = adjacency.length;
        if (n === 0) return true;
        
        const visited = Array(n).fill(false);
        const stack = [0];
        let count = 0;
        
        while (stack.length > 0) {
          const node = stack.pop();
          if (!visited[node]) {
            visited[node] = true;
            count++;
            
            for (let i = 0; i < n; i++) {
              if (adjacency[node][i] && !visited[i]) {
                stack.push(i);
              }
            }
          }
        }
        
        return count === n;
      }

      // Count edges
      countEdges(adjacency) {
        let count = 0;
        const n = adjacency.length;
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            if (adjacency[i][j]) count++;
          }
        }
        return count;
      }
    }

    // Graph Visualizer
    class GraphVisualizer {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.setupCanvas();
        
        this.nodes = [];
        this.adjacency = [];
        this.eigendata = null;
        this.selectedEigenvector = -1;
        
        this.nodeRadius = 20;
        this.edgeWidth = 2;
        
        this.editMode = false;
        this.selectedNode = -1;
        this.hoveredNode = -1;
        this.isDragging = false;
        this.dragNode = -1;
        this.dragOffset = { x: 0, y: 0 };
        
        this.setupInteraction();
      }

      setupCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
        
        // Handle high DPI displays
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
      }

      setupInteraction() {
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('mouseleave', () => this.handleMouseLeave());
        
        // Touch support
        this.canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          this.handleMouseDown(mouseEvent);
        });
        
        this.canvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          this.handleMouseMove(mouseEvent);
        });
        
        this.canvas.addEventListener('touchend', (e) => {
          e.preventDefault();
          this.handleMouseUp(e);
        });
      }

      handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const clickedNode = this.getNodeAt(x, y);
        
        if (this.editMode) {
          if (clickedNode !== -1) {
            if (this.selectedNode === -1) {
              this.selectedNode = clickedNode;
            } else if (this.selectedNode !== clickedNode) {
              this.toggleEdge(this.selectedNode, clickedNode);
              this.selectedNode = -1;
            } else {
              this.selectedNode = -1;
            }
          }
        } else {
          if (clickedNode !== -1) {
            this.isDragging = true;
            this.dragNode = clickedNode;
            this.dragOffset.x = x - this.nodes[clickedNode].x;
            this.dragOffset.y = y - this.nodes[clickedNode].y;
            this.canvas.classList.add('dragging');
          }
        }
        
        this.render();
      }

      handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (this.isDragging && this.dragNode !== -1) {
          this.nodes[this.dragNode].x = x - this.dragOffset.x;
          this.nodes[this.dragNode].y = y - this.dragOffset.y;
          this.render();
        } else {
          const hoveredNode = this.getNodeAt(x, y);
          if (hoveredNode !== this.hoveredNode) {
            this.hoveredNode = hoveredNode;
            this.render();
          }
        }
      }

      handleMouseUp(e) {
        this.isDragging = false;
        this.dragNode = -1;
        this.canvas.classList.remove('dragging');
      }

      handleMouseLeave() {
        this.isDragging = false;
        this.dragNode = -1;
        this.hoveredNode = -1;
        this.canvas.classList.remove('dragging');
        this.render();
      }

      getNodeAt(x, y) {
        for (let i = 0; i < this.nodes.length; i++) {
          const node = this.nodes[i];
          const dx = x - node.x;
          const dy = y - node.y;
          if (Math.sqrt(dx * dx + dy * dy) <= this.nodeRadius) {
            return i;
          }
        }
        return -1;
      }

      toggleEdge(i, j) {
        this.adjacency[i][j] = this.adjacency[i][j] ? 0 : 1;
        this.adjacency[j][i] = this.adjacency[i][j];
        
        if (this.onGraphChange) {
          this.onGraphChange();
        }
      }

      setEditMode(enabled) {
        this.editMode = enabled;
        this.selectedNode = -1;
        this.canvas.classList.toggle('edit-mode', enabled);
        this.render();
      }

      setGraph(adjacency, positions = null) {
        this.adjacency = adjacency;
        const n = adjacency.length;
        
        if (positions) {
          this.nodes = positions;
        } else {
          // Generate positions in a circle
          this.nodes = [];
          const centerX = this.canvas.width / 2;
          const centerY = this.canvas.height / 2;
          const radius = Math.min(centerX, centerY) - 50;
          
          for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n - Math.PI / 2;
            this.nodes.push({
              x: centerX + radius * Math.cos(angle),
              y: centerY + radius * Math.sin(angle)
            });
          }
        }
        
        this.render();
      }

      setEigendata(eigendata) {
        this.eigendata = eigendata;
      }

      setSelectedEigenvector(index) {
        this.selectedEigenvector = index;
        this.render();
      }

      render() {
        const ctx = this.ctx;
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Draw edges
        ctx.strokeStyle = '#cbd5e1';
        ctx.lineWidth = this.edgeWidth;
        
        for (let i = 0; i < this.nodes.length; i++) {
          for (let j = i + 1; j < this.nodes.length; j++) {
            if (this.adjacency[i][j]) {
              ctx.beginPath();
              ctx.moveTo(this.nodes[i].x, this.nodes[i].y);
              ctx.lineTo(this.nodes[j].x, this.nodes[j].y);
              ctx.stroke();
            }
          }
        }
        
        // Draw edge preview in edit mode
        if (this.editMode && this.selectedNode !== -1 && this.hoveredNode !== -1 && 
            this.selectedNode !== this.hoveredNode) {
          ctx.strokeStyle = this.adjacency[this.selectedNode][this.hoveredNode] ? '#ef4444' : '#10b981';
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(this.nodes[this.selectedNode].x, this.nodes[this.selectedNode].y);
          ctx.lineTo(this.nodes[this.hoveredNode].x, this.nodes[this.hoveredNode].y);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        // Draw nodes
        for (let i = 0; i < this.nodes.length; i++) {
          const node = this.nodes[i];
          
          // Determine node color based on eigenvector
          let fillColor = '#6366f1';
          if (this.selectedEigenvector >= 0 && this.eigendata) {
            const vec = this.eigendata.eigenvectors[this.selectedEigenvector];
            const value = vec[i];
            const normalized = (value - Math.min(...vec)) / (Math.max(...vec) - Math.min(...vec));
            
            // Color gradient from blue (negative) to red (positive)
            if (value < 0) {
              fillColor = `rgba(59, 130, 246, ${0.3 + 0.7 * (1 - normalized)})`;
            } else {
              fillColor = `rgba(239, 68, 68, ${0.3 + 0.7 * normalized})`;
            }
          }
          
          // Node appearance
          ctx.fillStyle = fillColor;
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 3;
          
          if (i === this.selectedNode) {
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 4;
          } else if (i === this.hoveredNode) {
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = 4;
          }
          
          ctx.beginPath();
          ctx.arc(node.x, node.y, this.nodeRadius, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
          
          // Node label
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 14px Inter';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(i.toString(), node.x, node.y);
        }
      }

      resetView() {
        this.setGraph(this.adjacency);
      }
    }

    // Main Application
    class SpectralGraphApp {
      constructor() {
        this.engine = new SpectralGraphEngine();
        this.visualizer = null;
        this.currentNodeCount = 5;
        this.currentAdjacency = null;
        this.currentEigendata = null;
        
        this.init();
      }

      init() {
        // Initialize canvas
        const canvas = document.getElementById('graph-canvas');
        this.visualizer = new GraphVisualizer(canvas);
        this.visualizer.onGraphChange = () => this.updateEigendata();
        
        // Setup controls
        this.setupTabs();
        this.setupPresets();
        this.setupNodeCount();
        this.setupToolbar();
        
        // Load initial graph
        this.loadPreset('cycle');
        
        // Handle window resize
        window.addEventListener('resize', () => {
          this.visualizer.setupCanvas();
          this.visualizer.render();
        });
      }

      setupTabs() {
        const tabs = document.querySelectorAll('.tab');
        const contents = document.querySelectorAll('.tab-content');
        
        tabs.forEach(tab => {
          tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            contents.forEach(c => c.classList.remove('active'));
            
            tab.classList.add('active');
            const contentId = tab.dataset.tab + '-tab';
            document.getElementById(contentId).classList.add('active');
          });
        });
      }

      setupPresets() {
        const presetButtons = document.querySelectorAll('.preset-btn');
        presetButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const preset = btn.dataset.preset;
            this.loadPreset(preset);
          });
        });
      }

      setupNodeCount() {
        const select = document.getElementById('node-count');
        select.addEventListener('change', () => {
          this.currentNodeCount = parseInt(select.value);
          if (this.currentAdjacency) {
            // Reload current structure with new node count
            const currentType = this.detectGraphType();
            if (currentType) {
              this.loadPreset(currentType);
            }
          }
        });
      }

      setupToolbar() {
        const editBtn = document.getElementById('edit-btn');
        const resetBtn = document.getElementById('reset-btn');
        
        editBtn.addEventListener('click', () => {
          const isActive = editBtn.classList.toggle('active');
          this.visualizer.setEditMode(isActive);
          editBtn.innerHTML = isActive ? 
            '<i class="fas fa-times"></i> Done' : 
            '<i class="fas fa-edit"></i> Edit Graph';
        });
        
        resetBtn.addEventListener('click', () => {
          this.visualizer.resetView();
        });
      }

      detectGraphType() {
        // Simple heuristic to detect graph type
        if (!this.currentAdjacency) return null;
        
        const n = this.currentAdjacency.length;
        const edges = this.engine.countEdges(this.currentAdjacency);
        
        if (edges === n - 1) {
          // Could be path or star
          let maxDegree = 0;
          for (let i = 0; i < n; i++) {
            const degree = this.currentAdjacency[i].reduce((sum, val) => sum + val, 0);
            maxDegree = Math.max(maxDegree, degree);
          }
          return maxDegree === n - 1 ? 'star' : 'path';
        } else if (edges === n) {
          return 'cycle';
        } else if (edges === n * (n - 1) / 2) {
          return 'complete';
        }
        
        return null;
      }

      loadPreset(type) {
        this.currentAdjacency = this.engine.generatePreset(type, this.currentNodeCount);
        this.visualizer.setGraph(this.currentAdjacency);
        this.updateEigendata();
      }

      updateEigendata() {
        const laplacian = this.engine.computeLaplacian(this.currentAdjacency);
        this.currentEigendata = this.engine.computeEigendecomposition(laplacian);
        
        this.visualizer.setEigendata(this.currentEigendata);
        this.updateEigenvalueDisplay();
        this.updateEigenvectorDisplay();
        this.updateProperties();
      }

      updateEigenvalueDisplay() {
        const container = document.getElementById('eigenvalue-list');
        container.innerHTML = '';
        
        const isConnected = this.engine.isConnected(this.currentAdjacency);
        
        this.currentEigendata.eigenvalues.forEach((value, i) => {
          const item = document.createElement('div');
          item.className = 'eigenvalue-item';
          
          const info = this.getEigenvalueInfo(i, value, isConnected);
          
          item.innerHTML = `
            <div class="eigenvalue-header">
              <span class="eigenvalue-label">λ${i + 1}</span>
              <span class="eigenvalue-value">${value.toFixed(4)}</span>
            </div>
            <div class="eigenvalue-info">${info}</div>
          `;
          
          container.appendChild(item);
        });
      }

      getEigenvalueInfo(index, value, isConnected) {
        if (index === 0) {
          return isConnected ? 'Always 0 (connected graph)' : 'Graph has multiple components!';
        } else if (index === 1) {
          if (value < 0.01) return 'Very low - graph nearly disconnected!';
          if (value < 0.5) return 'Low connectivity';
          if (value < 1.5) return 'Moderate connectivity';
          return 'High connectivity';
        } else if (index === this.currentEigendata.eigenvalues.length - 1) {
          return 'Maximum eigenvalue';
        }
        return '';
      }

      updateEigenvectorDisplay() {
        const container = document.getElementById('eigenvector-display');
        container.innerHTML = '';
        
        this.currentEigendata.eigenvectors.forEach((vec, i) => {
          const card = document.createElement('div');
          card.className = 'eigenvector-card';
          if (i === this.visualizer.selectedEigenvector) {
            card.classList.add('active');
          }
          
          const preview = vec.map(v => {
            const normalized = (v - Math.min(...vec)) / (Math.max(...vec) - Math.min(...vec) || 1);
            const color = v < 0 ? 
              `rgba(59, 130, 246, ${0.3 + 0.7 * (1 - normalized)})` :
              `rgba(239, 68, 68, ${0.3 + 0.7 * normalized})`;
            return `<div class="node-value" style="background: ${color}"></div>`;
          }).join('');
          
          const description = this.getEigenvectorDescription(i);
          
          card.innerHTML = `
            <div class="eigenvector-header">Eigenvector ${i + 1}</div>
            <div class="eigenvector-preview">${preview}</div>
            <div class="eigenvector-description">${description}</div>
          `;
          
          card.addEventListener('click', () => {
            document.querySelectorAll('.eigenvector-card').forEach(c => c.classList.remove('active'));
            card.classList.add('active');
            this.visualizer.setSelectedEigenvector(i);
          });
          
          container.appendChild(card);
        });
      }

      getEigenvectorDescription(index) {
        if (index === 0) return 'Constant (all nodes equal)';
        if (index === 1) return 'Fiedler vector - finds graph cuts';
        if (index === 2) return 'Second harmonic';
        return `Mode ${index + 1}`;
      }

      updateProperties() {
        const edges = this.engine.countEdges(this.currentAdjacency);
        const eigenvalues = this.currentEigendata.eigenvalues;
        const isConnected = this.engine.isConnected(this.currentAdjacency);
        
        document.getElementById('num-edges').textContent = edges;
        document.getElementById('connectivity').textContent = eigenvalues[1].toFixed(3);
        document.getElementById('spectral-gap').textContent = 
          isConnected ? (eigenvalues[1] - eigenvalues[0]).toFixed(3) : 'Disconnected!';
        document.getElementById('max-eigenvalue').textContent = 
          eigenvalues[eigenvalues.length - 1].toFixed(3);
      }
    }

    // Initialize application
    document.addEventListener('DOMContentLoaded', () => {
      new SpectralGraphApp();
    });
  </script>
</body>
</html>